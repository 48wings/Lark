//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var __define =this.__define || function (o, p, a) { Object.defineProperty(o, p, { configurable:true,enumerable:true,get:a.g,set:a.s }) };
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 属性设置操作
         */
        var SetProperty = (function () {
            /**
             * 创建一个SetProperty实例
             */
            function SetProperty(target, name, value) {
                this.target = target;
                this.name = name;
                this.value = value;
            }var d = __define,c=SetProperty;p=c.prototype;
            /**
             * 应用覆盖。将保留原始值，以便以后可以在 remove() 方法中恢复该值。
             * @param skin 皮肤附加到的主机组件
             */
            p.apply = function (skin) {
                var obj = this.target ? skin[this.target] : skin;
                if (!obj)
                    return;
                this.oldValue = obj[this.name];
                this.setPropertyValue(obj, this.name, this.value, this.oldValue);
            };
            /**
             * 删除覆盖。在 apply() 方法中记住的值将被恢复。
             * @param skin 皮肤附加到的主机组件
             */
            p.remove = function (skin) {
                var obj = this.target ? skin[this.target] : skin;
                if (!obj)
                    return;
                this.setPropertyValue(obj, this.name, this.oldValue, this.oldValue);
                this.oldValue = null;
            };
            /**
             * 设置属性值
             */
            p.setPropertyValue = function (obj, name, value, valueForType) {
                if (value === undefined || value === null)
                    obj[name] = value;
                else if (typeof (valueForType) == "number")
                    obj[name] = +value;
                else if (typeof (valueForType) == "boolean")
                    obj[name] = this.toBoolean(value);
                else
                    obj[name] = value;
            };
            /**
             * 转成Boolean值
             */
            p.toBoolean = function (value) {
                if (typeof (value) == "string")
                    return value.toLowerCase() == "true";
                return value != false;
            };
            return SetProperty;
        })();
        gui.SetProperty = SetProperty;
        SetProperty.prototype.__class__ = "lark.gui.SetProperty";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 显示元素添加操作
         */
        var AddItems = (function () {
            /**
             * 创建一个AddItems实例
             */
            function AddItems(target, propertyName, position, relativeTo) {
                this.target = target;
                this.propertyName = propertyName;
                this.position = position;
                this.relativeTo = relativeTo;
            }var d = __define,c=AddItems;p=c.prototype;
            /**
             * 应用覆盖。将保留原始值，以便以后可以在 remove() 方法中恢复该值。
             * @param skin 皮肤附加到的主机组件
             */
            p.apply = function (skin) {
                var index;
                var relative = skin[this.relativeTo];
                var target = skin[this.target];
                var container = this.propertyName ? skin[this.propertyName] : skin.hostComponent;
                if (!target || !container)
                    return;
                switch (this.position) {
                    case 0 /* FIRST */:
                        index = 0;
                        break;
                    case 1 /* LAST */:
                        index = -1;
                        break;
                    case 2 /* BEFORE */:
                        index = container.getChildIndex(relative);
                        break;
                    case 3 /* AFTER */:
                        index = container.getChildIndex(relative) + 1;
                        break;
                }
                if (index == -1)
                    index = container.numChildren;
                container.addChildAt(target, index);
            };
            /**
             * 删除覆盖。在 apply() 方法中记住的值将被恢复。
             * @param skin 皮肤附加到的主机组件
             */
            p.remove = function (skin) {
                var container = this.propertyName ? skin[this.propertyName] : skin.hostComponent;
                var target = skin[this.target];
                if (!target || !container)
                    return;
                if (target.$parent === container) {
                    container.removeChild(target);
                }
            };
            return AddItems;
        })();
        gui.AddItems = AddItems;
        AddItems.prototype.__class__ = "lark.gui.AddItems";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * BitmapFillMode 类定义 Image 控件的图像填充方式。
         * BitmapFillMode 类定义了调整大小模式的一个枚举，这些模式确定 Bitmap 如何填充由布局系统指定的尺寸。
         */
        var BitmapFillMode = (function () {
            function BitmapFillMode() {
            }var d = __define,c=BitmapFillMode;p=c.prototype;
            /**
             * 在区域的边缘处截断不显示位图。
             */
            BitmapFillMode.CLIP = "clip";
            /**
             * 重复位图以填充区域。
             */
            BitmapFillMode.REPEAT = "repeat";
            /**
             * 拉伸位图以填充区域。
             */
            BitmapFillMode.SCALE = "scale";
            return BitmapFillMode;
        })();
        gui.BitmapFillMode = BitmapFillMode;
        BitmapFillMode.prototype.__class__ = "lark.gui.BitmapFillMode";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var player;
    (function (player) {
        player.XML;
    })(player = lark.player || (lark.player = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var player;
    (function (player) {
        /**
         * GUI命名空间
         */
        player.NS_E = "http://ns.egret-labs.org/egret";
        /**
         * Wing命名空间
         */
        player.NS_W = "http://ns.egret-labs.org/wing";
        var basicTypes = ["Array", "boolean", "string", "number"];
        var GUI_MODULE = "lark.gui.";
        var hashCount = 0;
        var EXMLConfig = (function () {
            function EXMLConfig() {
                this.properties = {};
            }var d = __define,c=EXMLConfig;p=c.prototype;
            p.describe = function (instance) {
                if (!instance) {
                    return null;
                }
                var prototype = Object.getPrototypeOf(instance);
                if (!prototype) {
                    return null;
                }
                var info;
                if (prototype.hasOwnProperty("__hashCode__")) {
                    info = this.properties[prototype.__hashCode__];
                    if (info) {
                        return info;
                    }
                }
                var superProto = Object.getPrototypeOf(prototype);
                if (!superProto) {
                    return null;
                }
                var superInstance = getInstanceOf(superProto.constructor);
                var superInfo = this.describe(superInstance);
                if (superInfo) {
                    function factory() {
                    }
                    factory.prototype = superInfo;
                    info = new factory();
                }
                else {
                    info = {};
                }
                if (DEBUG) {
                    info.__class__ = prototype.constructor.name;
                }
                var keys = Object.keys(prototype).concat(Object.keys(instance));
                var length = keys.length;
                var meta = instance.__meta__;
                for (var i = 0; i < length; i++) {
                    var key = keys[i];
                    if (key == "constructor" || key.charAt(0) == "_" || key.charAt(0) == "$") {
                        continue;
                    }
                    var resultType;
                    if (meta && meta[key]) {
                        resultType = meta[key];
                    }
                    else if (isArray(instance[key])) {
                        resultType = "Array";
                    }
                    else {
                        resultType = typeof instance[key];
                        if (resultType == "function") {
                            continue;
                        }
                        if (basicTypes.indexOf(resultType) == -1) {
                            resultType = "any";
                        }
                    }
                    info[key] = resultType;
                }
                prototype.__hashCode__ = hashCount++;
                this.properties[prototype.__hashCode__] = info;
                return info;
            };
            /**
             * 根据类的短名ID和命名空间获取完整类名(以"."分隔)
             * @param id 类的短名ID
             * @param ns 命名空间
             */
            p.getClassNameById = function (id, ns) {
                var name = "";
                if (basicTypes.indexOf(id) != -1) {
                    return id;
                }
                if (ns == player.NS_W) {
                }
                else if (!ns || ns == player.NS_E) {
                    name = GUI_MODULE + id;
                }
                else {
                    name = ns.substring(0, ns.length - 1) + id;
                }
                if (!getPrototypeOf(name)) {
                    name = "";
                }
                return name;
            };
            /**
             * 根据ID获取对应的默认属性
             * @param id 类的短名ID
             * @param ns 命名空间
             * @return 默认属性名
             */
            p.getDefaultPropById = function (id, ns) {
                var className = this.getClassNameById(id, ns);
                var prototype = getPrototypeOf(className);
                if (!prototype) {
                    name = "";
                }
                return prototype.__defaultProperty__;
            };
            /**
             * 获取指定属性的类型,返回基本数据类型："boolean","string","number","any"。
             * @param property 属性名
             * @param className 要查询的完整类名
             */
            p.getPropertyType = function (property, className) {
                if (className == "Object") {
                    return "any";
                }
                var resultType = "";
                var prototype = getPrototypeOf(className);
                if (prototype) {
                    if (!prototype.hasOwnProperty("__hashCode__")) {
                        var clazz = lark.getDefinitionByName(className);
                        var instance = getInstanceOf(clazz);
                        if (!instance) {
                            if (DEBUG) {
                                lark.$warn(2104, className);
                            }
                            return resultType;
                        }
                        this.describe(instance);
                    }
                    var info = this.properties[prototype.__hashCode__];
                    if (info) {
                        resultType = info[property];
                    }
                }
                return resultType;
            };
            return EXMLConfig;
        })();
        player.EXMLConfig = EXMLConfig;
        EXMLConfig.prototype.__class__ = "lark.player.EXMLConfig";
        /**
         * 判断一个对象是数组
         */
        function isArray(o) {
            return Object.prototype.toString.call(o) === '[object Array]';
        }
        /**
         * 获取一个类名对应的prototype引用
         */
        function getPrototypeOf(className) {
            var clazz = lark.getDefinitionByName(className);
            if (!clazz) {
                return null;
            }
            return clazz.prototype;
        }
        /**
         * 创建一个类名对应的实例
         */
        function getInstanceOf(clazz) {
            if (!clazz) {
                return null;
            }
            try {
                var instance = new clazz();
            }
            catch (e) {
                return null;
            }
            return instance;
        }
    })(player = lark.player || (lark.player = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 为一个类定义注册运行时属性类型，以便运行时的EXML文件解析过程能获取准确的属性类型。大多数情况下，您都不需要手动调用此方法显式注册属性类型。
         * 仅当您有一个自定义的GUI组件，需要在EXML中用标签描述时可能需要显式注册，但以下情况除外：
         * 当属性类型为基本数据类型：boolean,number,string,Array这四种其中之一时，您只需要为自定义的属性赋值上正确的初始值，
         * 运行时EXML解析器就能通过初始值自动分析出正确的属性类型。
         * 若您无法为属性赋值上正确的初始值时(有初始值，比如null),运行时EXML解析器会把此属性当做string来处理，若完全没有初始值，将会报错找不到节点属性，
         * 这种情况下可以手动调用此方法显式注册属性类型。
         *
         * @param classDefinition 要注册的类定义。
         * @param property 要注册的属性,注意属性名不能以 _ 或 $ 符开头。
         * @param type 要注册的类型,例如：“boolean","number","string","Array","lark.gui.ClassFactory","lark.Rectangle"
         * @param asDefault 是否将此属性注册为组件的默认属性,一个组件只可以设置一个默认属性。注册了组件默认属性后，在EXML中可以使用省略属性节点的写法，
         * 例如：
         *
         * <e:Scroller>
         *     <e:viewport>
         *         <e:Group/>
         *     </e:viewport>
         * </e:Scroller>
         *
         * 因为 viewport 已经注册为 Scroller 的默认属性，上面的例子可以等效为：
         *
         * <e:Scroller>
         *     <e:Group/>
         * </e:Scroller>
         *
         */
        function registerProperty(classDefinition, property, type, asDefault) {
            if (DEBUG) {
                if (!classDefinition) {
                    lark.$error(1003, "classDefinition");
                }
                if (!classDefinition.prototype) {
                    lark.$error(1012, "classDefinition");
                }
                if (!property) {
                    lark.$error(1003, "property");
                }
                if (!type) {
                    lark.$error(1003, "type");
                }
            }
            var prototype = classDefinition.prototype;
            prototype.__meta__ = prototype.__meta__ || {};
            prototype.__meta__[property] = type;
            if (asDefault) {
                prototype.__defaultProperty__ = property;
            }
        }
        gui.registerProperty = registerProperty;
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var lark;
(function (lark) {
    var player;
    (function (player) {
        var STATE = "lark.gui.State";
        var ADD_ITEMS = "lark.gui.AddItems";
        var SET_PROPERTY = "lark.gui.SetProperty";
        /**
         * 代码生成工具基类
         */
        var CodeBase = (function () {
            function CodeBase() {
                this.indent = 0;
            }var d = __define,c=CodeBase;p=c.prototype;
            p.toCode = function () {
                return "";
            };
            /**
             * 获取缩进字符串
             */
            p.getIndent = function (indent) {
                if (indent === void 0)
                    indent = this.indent;
                var str = "";
                for (var i = 0; i < indent; i++) {
                    str += "	";
                }
                return str;
            };
            return CodeBase;
        })();
        player.CodeBase = CodeBase;
        CodeBase.prototype.__class__ = "lark.player.CodeBase";
        var CpClass = (function (_super) {
            __extends(CpClass, _super);
            function CpClass() {
                _super.apply(this, arguments);
                /**
                 * 类名,不包括模块名
                 */
                this.className = "";
                /**
                 * 父类类名,包括完整模块名
                 */
                this.superClass = "";
                /**
                 * 内部类区块
                 */
                this.innerClassBlock = [];
                /**
                 * 变量定义区块
                 */
                this.variableBlock = [];
                /**
                 * 函数定义区块
                 */
                this.functionBlock = [];
            }var d = __define,c=CpClass;p=c.prototype;
            /**
             * 添加一个内部类
             */
            p.addInnerClass = function (clazz) {
                if (this.innerClassBlock.indexOf(clazz) == -1) {
                    this.innerClassBlock.push(clazz);
                }
            };
            /**
             * 添加变量
             */
            p.addVariable = function (variableItem) {
                if (this.variableBlock.indexOf(variableItem) == -1) {
                    this.variableBlock.push(variableItem);
                }
            };
            /**
             * 根据变量名获取变量定义
             */
            p.getVariableByName = function (name) {
                var list = this.variableBlock;
                var length = list.length;
                for (var i = 0; i < length; i++) {
                    var item = list[i];
                    if (item.name == name) {
                        return item;
                    }
                }
                return null;
            };
            /**
             * 添加函数
             */
            p.addFunction = function (functionItem) {
                if (this.functionBlock.indexOf(functionItem) == -1) {
                    this.functionBlock.push(functionItem);
                }
            };
            /**
             * 根据函数名返回函数定义块
             */
            p.getFuncByName = function (name) {
                var list = this.functionBlock;
                var length = list.length;
                for (var i = 0; i < length; i++) {
                    var item = list[i];
                    if (item.name == name) {
                        return item;
                    }
                }
                return null;
            };
            p.toCode = function () {
                var indent = this.indent;
                var indentStr = this.getIndent(indent);
                var indent1Str = this.getIndent(indent + 1);
                var indent2Str = this.getIndent(indent + 2);
                //打印类起始块
                var returnStr = indentStr + "(function (";
                if (this.superClass) {
                    returnStr += "_super) {\n" + indent1Str + "__extends(" + this.className + ", _super);\n";
                }
                else {
                    returnStr += ") {\n";
                }
                //打印内部类列表
                var innerClasses = this.innerClassBlock;
                var length = innerClasses.length;
                for (var i = 0; i < length; i++) {
                    var clazz = innerClasses[i];
                    clazz.indent = indent + 1;
                    returnStr += indent1Str + "var " + clazz.className + " = " + clazz.toCode() + "\n\n";
                }
                returnStr += indent1Str + "function " + this.className + "() {\n";
                if (this.superClass) {
                    returnStr += indent2Str + "_super.call(this);\n";
                }
                //打印变量列表
                var variables = this.variableBlock;
                length = variables.length;
                for (i = 0; i < length; i++) {
                    var variable = variables[i];
                    if (variable.defaultValue) {
                        returnStr += indent2Str + variable.toCode() + "\n";
                    }
                }
                //打印构造函数
                if (this.constructCode) {
                    var codes = this.constructCode.toCode().split("\n");
                    length = codes.length;
                    for (i = 0; i < length; i++) {
                        var code = codes[i];
                        returnStr += indent2Str + code + "\n";
                    }
                }
                returnStr += indent1Str + "}\n";
                returnStr += indent1Str + "var _proto = " + this.className + ".prototype;\n\n";
                //打印函数列表
                var functions = this.functionBlock;
                length = functions.length;
                for (i = 0; i < length; i++) {
                    var functionItem = functions[i];
                    functionItem.indent = indent + 1;
                    returnStr += functionItem.toCode() + "\n";
                }
                //打印类结尾
                returnStr += indent1Str + "return " + this.className + ";\n" + indentStr;
                if (this.superClass) {
                    returnStr += "})(" + this.superClass + ");";
                }
                else {
                    returnStr += "})();";
                }
                return returnStr;
            };
            return CpClass;
        })(CodeBase);
        player.CpClass = CpClass;
        CpClass.prototype.__class__ = "lark.player.CpClass";
        var CpCodeBlock = (function (_super) {
            __extends(CpCodeBlock, _super);
            function CpCodeBlock() {
                _super.apply(this, arguments);
                this.lines = [];
            }var d = __define,c=CpCodeBlock;p=c.prototype;
            /**
             * 添加变量声明语句
             * @param name 变量名
             * @param value 变量初始值
             */
            p.addVar = function (name, value) {
                var valueStr = value ? " = " + value : "";
                this.addCodeLine("var " + name + valueStr + ";");
            };
            /**
             * 添加赋值语句
             * @param target 要赋值的目标
             * @param value 值
             * @param prop 目标的属性(用“.”访问)，不填则是对目标赋值
             */
            p.addAssignment = function (target, value, prop) {
                var propStr = prop ? "." + prop : "";
                this.addCodeLine(target + propStr + " = " + value + ";");
            };
            /**
             * 添加返回值语句
             */
            p.addReturn = function (data) {
                this.addCodeLine("return " + data + ";");
            };
            /**
             * 添加一条空行
             */
            p.addEmptyLine = function () {
                this.addCodeLine("");
            };
            /**
             * 开始添加if语句块,自动调用startBlock();
             */
            p.startIf = function (expression) {
                this.addCodeLine("if(" + expression + ")");
                this.startBlock();
            };
            /**
             * 开始else语句块,自动调用startBlock();
             */
            p.startElse = function () {
                this.addCodeLine("else");
                this.startBlock();
            };
            /**
             * 开始else if语句块,自动调用startBlock();
             */
            p.startElseIf = function (expression) {
                this.addCodeLine("else if(" + expression + ")");
                this.startBlock();
            };
            /**
             * 添加一个左大括号，开始新的语句块
             */
            p.startBlock = function () {
                this.addCodeLine("{");
                this.indent++;
            };
            /**
             * 添加一个右大括号,结束当前的语句块
             */
            p.endBlock = function () {
                this.indent--;
                this.addCodeLine("}");
            };
            /**
             * 添加执行函数语句块
             * @param functionName 要执行的函数名称
             * @param args 函数参数列表
             */
            p.doFunction = function (functionName, args) {
                var argsStr = args.join(",");
                this.addCodeLine(functionName + "(" + argsStr + ")");
            };
            /**
             * 添加一行代码
             */
            p.addCodeLine = function (code) {
                this.lines.push(this.getIndent() + code);
            };
            /**
             * 添加一行代码到指定行
             */
            p.addCodeLineAt = function (code, index) {
                this.lines.splice(index, 0, this.getIndent() + code);
            };
            /**
             * 是否存在某行代码内容
             */
            p.containsCodeLine = function (code) {
                return this.lines.indexOf(code) != -1;
            };
            /**
             * 在结尾追加另一个代码块的内容
             */
            p.concat = function (cb) {
                this.lines = this.lines.concat(cb.lines);
            };
            p.toCode = function () {
                return this.lines.join("\n");
            };
            return CpCodeBlock;
        })(CodeBase);
        player.CpCodeBlock = CpCodeBlock;
        CpCodeBlock.prototype.__class__ = "lark.player.CpCodeBlock";
        var CpFunction = (function (_super) {
            __extends(CpFunction, _super);
            function CpFunction() {
                _super.apply(this, arguments);
                /**
                 * 代码块
                 */
                this.codeBlock = null;
                this.isGet = false;
                /**
                 * 函数名
                 */
                this.name = "";
            }var d = __define,c=CpFunction;p=c.prototype;
            p.toCode = function () {
                var indentStr = this.getIndent();
                var indent1Str = this.getIndent(this.indent + 1);
                var codeIndent;
                var returnStr = indentStr;
                if (this.isGet) {
                    codeIndent = this.getIndent(this.indent + 2);
                    returnStr += 'Object.defineProperty(_proto, "skinParts", {\n';
                    returnStr += indent1Str + "get: function () {\n";
                }
                else {
                    codeIndent = indent1Str;
                    returnStr += "_proto." + this.name + " = function () {\n";
                }
                if (this.codeBlock) {
                    var lines = this.codeBlock.toCode().split("\n");
                    var length = lines.length;
                    for (var i = 0; i < length; i++) {
                        var line = lines[i];
                        returnStr += codeIndent + line + "\n";
                    }
                }
                if (this.isGet) {
                    returnStr += indent1Str + "},\n" + indent1Str + "enumerable: true,\n" + indent1Str + "configurable: true\n" + indentStr + "});";
                }
                else {
                    returnStr += indentStr + "};";
                }
                return returnStr;
            };
            return CpFunction;
        })(CodeBase);
        player.CpFunction = CpFunction;
        CpFunction.prototype.__class__ = "lark.player.CpFunction";
        var CpVariable = (function (_super) {
            __extends(CpVariable, _super);
            function CpVariable(name, defaultValue) {
                _super.call(this);
                this.indent = 2;
                this.name = name;
                this.defaultValue = defaultValue;
            }var d = __define,c=CpVariable;p=c.prototype;
            p.toCode = function () {
                if (!this.defaultValue) {
                    return "";
                }
                return "this." + this.name + " = " + this.defaultValue + ";";
            };
            return CpVariable;
        })(CodeBase);
        player.CpVariable = CpVariable;
        CpVariable.prototype.__class__ = "lark.player.CpVariable";
        var CpState = (function (_super) {
            __extends(CpState, _super);
            function CpState(name, stateGroups) {
                if (stateGroups === void 0) { stateGroups = null; }
                _super.call(this);
                /**
                 * 视图状态名称
                 */
                this.name = "";
                this.stateGroups = [];
                this.addItems = [];
                this.setProperty = [];
                this.name = name;
                if (stateGroups)
                    this.stateGroups = stateGroups;
            }var d = __define,c=CpState;p=c.prototype;
            /**
             * 添加一个覆盖
             */
            p.addOverride = function (item) {
                if (item instanceof CpAddItems)
                    this.addItems.push(item);
                else
                    this.setProperty.push(item);
            };
            p.toCode = function () {
                var indentStr = this.getIndent(1);
                var returnStr = "new " + STATE + " (\"" + this.name + "\",\n" + indentStr + "[\n";
                var index = 0;
                var isFirst = true;
                var overrides = this.addItems.concat(this.setProperty);
                while (index < overrides.length) {
                    if (isFirst)
                        isFirst = false;
                    else
                        returnStr += ",\n";
                    var item = overrides[index];
                    var codes = item.toCode().split("\n");
                    var length = codes.length;
                    for (var i = 0; i < length; i++) {
                        var code = codes[i];
                        codes[i] = indentStr + indentStr + code;
                    }
                    returnStr += codes.join("\n");
                    index++;
                }
                returnStr += "\n" + indentStr + "])";
                return returnStr;
            };
            return CpState;
        })(CodeBase);
        player.CpState = CpState;
        CpState.prototype.__class__ = "lark.player.CpState";
        var CpAddItems = (function (_super) {
            __extends(CpAddItems, _super);
            function CpAddItems(target, propertyName, position, relativeTo) {
                _super.call(this);
                this.target = target;
                this.propertyName = propertyName;
                this.position = position;
                this.relativeTo = relativeTo;
            }var d = __define,c=CpAddItems;p=c.prototype;
            p.toCode = function () {
                var indentStr = this.getIndent(1);
                var returnStr = "new " + ADD_ITEMS + "(\"" + this.target + "\",\"" + this.propertyName + "\",\"" + this.position + "\",\"" + this.relativeTo + "\")";
                return returnStr;
            };
            return CpAddItems;
        })(CodeBase);
        player.CpAddItems = CpAddItems;
        CpAddItems.prototype.__class__ = "lark.player.CpAddItems";
        var CpSetProperty = (function (_super) {
            __extends(CpSetProperty, _super);
            function CpSetProperty(target, name, value) {
                _super.call(this);
                this.target = target;
                this.name = name;
                this.value = value;
            }var d = __define,c=CpSetProperty;p=c.prototype;
            p.toCode = function () {
                var indentStr = this.getIndent(1);
                return "new " + SET_PROPERTY + "(\"" + this.target + "\",\"" + this.name + "\"," + this.value + ")";
            };
            return CpSetProperty;
        })(CodeBase);
        player.CpSetProperty = CpSetProperty;
        CpSetProperty.prototype.__class__ = "lark.player.CpSetProperty";
    })(player = lark.player || (lark.player = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        var loaderPool = [];
        /**
         * 默认的IAssetAdapter接口实现
         */
        var DefaultAssetAdapter = (function () {
            function DefaultAssetAdapter() {
            }var d = __define,c=DefaultAssetAdapter;p=c.prototype;
            /**
             * 解析素材
             * @param source 待解析的新素材标识符
             * @param callBack 解析完成回调函数，示例：callBack(content:any,source:string):void;
             * @param thisObject callBack的 this 引用
             */
            p.getAsset = function (source, callBack, thisObject) {
                var loader = loaderPool.pop();
                if (!loader) {
                    loader = new lark.ImageLoader();
                }
                loader.on(lark.Event.COMPLETE, onLoadFinish, null);
                loader.on(lark.Event.IO_ERROR, onLoadFinish, null);
                loader.load(source);
                function onLoadFinish(event) {
                    loader.removeListener(lark.Event.COMPLETE, onLoadFinish, null);
                    loader.removeListener(lark.Event.IO_ERROR, onLoadFinish, null);
                    var data;
                    if (event.type == lark.Event.COMPLETE) {
                        data = loader.data;
                        loader.data = null;
                    }
                    loaderPool.push(loader);
                    callBack.call(thisObject, data, source);
                }
            };
            return DefaultAssetAdapter;
        })();
        gui.DefaultAssetAdapter = DefaultAssetAdapter;
        DefaultAssetAdapter.prototype.__class__ = "lark.gui.DefaultAssetAdapter";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var web;
    (function (web) {
        /**
         * XML节点基类
         */
        var XMLNode = (function () {
            function XMLNode(nodeType, parent) {
                this.nodeType = nodeType;
                this.parent = parent;
            }var d = __define,c=XMLNode;p=c.prototype;
            return XMLNode;
        })();
        web.XMLNode = XMLNode;
        XMLNode.prototype.__class__ = "lark.web.XMLNode";
        /**
         * XML节点对象
         */
        var XML = (function (_super) {
            __extends(XML, _super);
            function XML(localName, parent, prefix, namespace, name) {
                _super.call(this, 1, parent);
                /**
                 * 当前节点上的属性列表
                 */
                this.attributes = {};
                /**
                 * 当前节点的子节点列表
                 */
                this.children = [];
                this.localName = localName;
                this.prefix = prefix;
                this.namespace = namespace;
                this.name = name;
            }var d = __define,c=XML;p=c.prototype;
            return XML;
        })(XMLNode);
        web.XML = XML;
        XML.prototype.__class__ = "lark.web.XML";
        /**
         * XML文本节点
         */
        var XMLText = (function (_super) {
            __extends(XMLText, _super);
            function XMLText(text, parent) {
                _super.call(this, 3, parent);
                this.text = text;
            }var d = __define,c=XMLText;p=c.prototype;
            return XMLText;
        })(XMLNode);
        web.XMLText = XMLText;
        XMLText.prototype.__class__ = "lark.web.XMLText";
        var parser = new DOMParser();
        /**
         * 解析字符串为XML对象
         * @param text 要解析的字符串
         */
        function parse(text) {
            var xmlDoc = parser.parseFromString(text, "text/xml");
            var length = xmlDoc.childNodes.length;
            for (var i = 0; i < length; i++) {
                var node = xmlDoc.childNodes[i];
                if (node.nodeType === 1) {
                    return parseNode(node, null);
                }
            }
            return null;
        }
        /**
         * 解析一个节点
         */
        function parseNode(node, parent) {
            if (node instanceof HTMLUnknownElement) {
                throw new Error(node.textContent);
            }
            var xml = new XML(node.localName, parent, node.prefix, node.namespaceURI, node.nodeName);
            var nodeAttributes = node.attributes;
            var attributes = xml.attributes;
            var length = nodeAttributes.length;
            for (var i = 0; i < length; i++) {
                var attributeNode = nodeAttributes[i];
                var name = attributeNode.name;
                if (name.indexOf("xmlns:") === 0) {
                    continue;
                }
                attributes[name] = attributeNode.value;
            }
            var childNodes = node.childNodes;
            length = childNodes.length;
            var children = xml.children;
            for (i = 0; i < length; i++) {
                var childNode = childNodes[i];
                var nodeType = childNode.nodeType;
                var childXML = null;
                if (nodeType === 1) {
                    childXML = parseNode(childNode, xml);
                }
                else if (nodeType === 3) {
                    var text = childNode.textContent.trim();
                    if (text) {
                        childXML = new XMLText(text, xml);
                    }
                }
                if (childXML) {
                    children.push(childXML);
                }
            }
            return xml;
        }
        lark.player.XML = { parse: parse };
    })(web = lark.web || (lark.web = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var player;
    (function (player) {
        var SOLUTION_TOLERANCE = 0.1;
        var MIN_MAX_TOLERANCE = 0.1;
        var MatrixUtil = (function () {
            function MatrixUtil() {
            }var d = __define,c=MatrixUtil;p=c.prototype;
            MatrixUtil.fitBounds = function (width, height, matrix, explicitWidth, explicitHeight, preferredWidth, preferredHeight, minWidth, minHeight, maxWidth, maxHeight) {
                if (lark.isNone(width) && lark.isNone(height))
                    return lark.Point.create(preferredWidth, preferredHeight);
                var newMinWidth = (minWidth < MIN_MAX_TOLERANCE) ? 0 : minWidth - MIN_MAX_TOLERANCE;
                var newMinHeight = (minHeight < MIN_MAX_TOLERANCE) ? 0 : minHeight - MIN_MAX_TOLERANCE;
                var newMaxWidth = maxWidth + MIN_MAX_TOLERANCE;
                var newMaxHeight = maxHeight + MIN_MAX_TOLERANCE;
                var actualSize;
                if (!lark.isNone(width) && !lark.isNone(height)) {
                    actualSize = calcUBoundsToFitTBounds(width, height, matrix, newMinWidth, newMinHeight, newMaxWidth, newMaxHeight);
                    if (!actualSize) {
                        var actualSize1;
                        actualSize1 = fitTBoundsWidth(width, matrix, explicitWidth, explicitHeight, preferredWidth, preferredHeight, newMinWidth, newMinHeight, newMaxWidth, newMaxHeight);
                        if (actualSize1) {
                            var fitHeight = transformSize(actualSize1.x, actualSize1.y, matrix).height;
                            if (fitHeight - SOLUTION_TOLERANCE > height) {
                                lark.Point.release(actualSize1);
                                actualSize1 = null;
                            }
                        }
                        var actualSize2;
                        actualSize2 = fitTBoundsHeight(height, matrix, explicitWidth, explicitHeight, preferredWidth, preferredHeight, newMinWidth, newMinHeight, newMaxWidth, newMaxHeight);
                        if (actualSize2) {
                            var fitWidth = transformSize(actualSize2.x, actualSize2.y, matrix).width;
                            if (fitWidth - SOLUTION_TOLERANCE > width) {
                                lark.Point.release(actualSize2);
                                actualSize2 = null;
                            }
                        }
                        if (actualSize1 && actualSize2) {
                            actualSize = ((actualSize1.x * actualSize1.y) > (actualSize2.x * actualSize2.y)) ? actualSize1 : actualSize2;
                        }
                        else if (actualSize1) {
                            actualSize = actualSize1;
                        }
                        else {
                            actualSize = actualSize2;
                        }
                        lark.Point.release(actualSize1);
                        lark.Point.release(actualSize2);
                    }
                    return actualSize;
                }
                else if (!lark.isNone(width)) {
                    return fitTBoundsWidth(width, matrix, explicitWidth, explicitHeight, preferredWidth, preferredHeight, newMinWidth, newMinHeight, newMaxWidth, newMaxHeight);
                }
                else {
                    return fitTBoundsHeight(height, matrix, explicitWidth, explicitHeight, preferredWidth, preferredHeight, newMinWidth, newMinHeight, newMaxWidth, newMaxHeight);
                }
            };
            return MatrixUtil;
        })();
        player.MatrixUtil = MatrixUtil;
        MatrixUtil.prototype.__class__ = "lark.player.MatrixUtil";
        function fitTBoundsWidth(width, matrix, explicitWidth, explicitHeight, preferredWidth, preferredHeight, minWidth, minHeight, maxWidth, maxHeight) {
            var actualSize;
            if (!lark.isNone(explicitWidth) && lark.isNone(explicitHeight)) {
                actualSize = calcUBoundsToFitTBoundsWidth(width, matrix, explicitWidth, preferredHeight, explicitWidth, minHeight, explicitWidth, maxHeight);
                if (actualSize)
                    return actualSize;
            }
            else if (lark.isNone(explicitWidth) && !lark.isNone(explicitHeight)) {
                actualSize = calcUBoundsToFitTBoundsWidth(width, matrix, preferredWidth, explicitHeight, minWidth, explicitHeight, maxWidth, explicitHeight);
                if (actualSize)
                    return actualSize;
            }
            actualSize = calcUBoundsToFitTBoundsWidth(width, matrix, preferredWidth, preferredHeight, minWidth, minHeight, maxWidth, maxHeight);
            return actualSize;
        }
        function fitTBoundsHeight(height, matrix, explicitWidth, explicitHeight, preferredWidth, preferredHeight, minWidth, minHeight, maxWidth, maxHeight) {
            var actualSize;
            if (!lark.isNone(explicitWidth) && lark.isNone(explicitHeight)) {
                actualSize = calcUBoundsToFitTBoundsHeight(height, matrix, explicitWidth, preferredHeight, explicitWidth, minHeight, explicitWidth, maxHeight);
                if (actualSize)
                    return actualSize;
            }
            else if (lark.isNone(explicitWidth) && !lark.isNone(explicitHeight)) {
                actualSize = calcUBoundsToFitTBoundsHeight(height, matrix, preferredWidth, explicitHeight, minWidth, explicitHeight, maxWidth, explicitHeight);
                if (actualSize)
                    return actualSize;
            }
            actualSize = calcUBoundsToFitTBoundsHeight(height, matrix, preferredWidth, preferredHeight, minWidth, minHeight, maxWidth, maxHeight);
            return actualSize;
        }
        function calcUBoundsToFitTBoundsHeight(h, matrix, preferredX, preferredY, minX, minY, maxX, maxY) {
            var m = matrix.$data;
            var b = m[1 /* b */];
            var d = m[3 /* d */];
            if (-1.0e-9 < b && b < +1.0e-9)
                b = 0;
            if (-1.0e-9 < d && d < +1.0e-9)
                d = 0;
            if (b == 0 && d == 0)
                return null;
            if (b == 0 && d == 0)
                return null;
            if (b == 0)
                return lark.Point.create(preferredX, h / Math.abs(d));
            else if (d == 0)
                return lark.Point.create(h / Math.abs(b), preferredY);
            var d1 = (b * d >= 0) ? d : -d;
            var s;
            var x;
            var y;
            if (d1 != 0 && preferredX > 0) {
                var invD1 = 1 / d1;
                preferredX = Math.max(minX, Math.min(maxX, preferredX));
                x = preferredX;
                y = (h - b * x) * invD1;
                if (minY <= y && y <= maxY && b * x + d1 * y >= 0) {
                    s = lark.Point.create(x, y);
                }
                y = (-h - b * x) * invD1;
                if (minY <= y && y <= maxY && b * x + d1 * y < 0) {
                    if (!s || transformSize(s.x, s.y, matrix).width > transformSize(x, y, matrix).width) {
                        lark.Point.release(s);
                        s = lark.Point.create(x, y);
                    }
                }
            }
            if (b != 0 && preferredY > 0) {
                var invB = 1 / b;
                preferredY = Math.max(minY, Math.min(maxY, preferredY));
                y = preferredY;
                x = (h - d1 * y) * invB;
                if (minX <= x && x <= maxX && b * x + d1 * y >= 0) {
                    if (!s || transformSize(s.x, s.y, matrix).width > transformSize(x, y, matrix).width)
                        s = lark.Point.create(x, y);
                }
                x = (-h - d1 * y) * invB;
                if (minX <= x && x <= maxX && b * x + d1 * y < 0) {
                    if (!s || transformSize(s.x, s.y, matrix).width > transformSize(x, y, matrix).width) {
                        lark.Point.release(s);
                        s = lark.Point.create(x, y);
                    }
                }
            }
            if (s)
                return s;
            var a = m[0 /* a */];
            var c = m[2 /* c */];
            var c1 = (a * c >= 0) ? c : -c;
            return solveEquation(b, d1, h, minX, minY, maxX, maxY, a, c1);
        }
        function calcUBoundsToFitTBoundsWidth(w, matrix, preferredX, preferredY, minX, minY, maxX, maxY) {
            var m = matrix.$data;
            var a = m[0 /* a */];
            var c = m[2 /* c */];
            if (-1.0e-9 < a && a < +1.0e-9)
                a = 0;
            if (-1.0e-9 < c && c < +1.0e-9)
                c = 0;
            if (a == 0 && c == 0)
                return null;
            if (a == 0)
                return lark.Point.create(preferredX, w / Math.abs(c));
            else if (c == 0)
                return lark.Point.create(w / Math.abs(a), preferredY);
            var c1 = (a * c >= 0) ? c : -c;
            var s;
            var x;
            var y;
            if (c1 != 0 && preferredX > 0) {
                var invC1 = 1 / c1;
                preferredX = Math.max(minX, Math.min(maxX, preferredX));
                x = preferredX;
                y = (w - a * x) * invC1;
                if (minY <= y && y <= maxY && a * x + c1 * y >= 0) {
                    s = lark.Point.create(x, y);
                }
                y = (-w - a * x) * invC1;
                if (minY <= y && y <= maxY && a * x + c1 * y < 0) {
                    if (!s || transformSize(s.x, s.y, matrix).height > transformSize(x, y, matrix).height) {
                        lark.Point.release(s);
                        s = lark.Point.create(x, y);
                    }
                }
            }
            if (a != 0 && preferredY > 0) {
                var invA = 1 / a;
                preferredY = Math.max(minY, Math.min(maxY, preferredY));
                y = preferredY;
                x = (w - c1 * y) * invA;
                if (minX <= x && x <= maxX && a * x + c1 * y >= 0) {
                    if (!s || transformSize(s.x, s.y, matrix).height > transformSize(x, y, matrix).height) {
                        lark.Point.release(s);
                        s = lark.Point.create(x, y);
                    }
                }
                x = (-w - c1 * y) * invA;
                if (minX <= x && x <= maxX && a * x + c1 * y < 0) {
                    if (!s || transformSize(s.x, s.y, matrix).height > transformSize(x, y, matrix).height) {
                        lark.Point.release(s);
                        s = lark.Point.create(x, y);
                    }
                }
            }
            if (s)
                return s;
            var b = m[1 /* b */];
            var d = m[3 /* d */];
            var d1 = (b * d >= 0) ? d : -d;
            return solveEquation(a, c1, w, minX, minY, maxX, maxY, b, d1);
        }
        function solveEquation(a, c, w, minX, minY, maxX, maxY, b, d) {
            if (a == 0 || c == 0)
                return null;
            var x;
            var y;
            var A = (w - minX * a) / c;
            var B = (w - maxX * a) / c;
            var rangeMinY = Math.max(minY, Math.min(A, B));
            var rangeMaxY = Math.min(maxY, Math.max(A, B));
            var det = (b * c - a * d);
            if (rangeMinY <= rangeMaxY) {
                if (Math.abs(det) < 1.0e-9) {
                    y = w / (a + c);
                }
                else {
                    y = b * w / det;
                }
                y = Math.max(rangeMinY, Math.min(y, rangeMaxY));
                x = (w - c * y) / a;
                return lark.Point.create(x, y);
            }
            A = -(minX * a + w) / c;
            B = -(maxX * a + w) / c;
            rangeMinY = Math.max(minY, Math.min(A, B));
            rangeMaxY = Math.min(maxY, Math.max(A, B));
            if (rangeMinY <= rangeMaxY) {
                if (Math.abs(det) < 1.0e-9) {
                    y = -w / (a + c);
                }
                else {
                    y = -b * w / det;
                }
                y = Math.max(rangeMinY, Math.min(y, rangeMaxY));
                x = (-w - c * y) / a;
                return lark.Point.create(x, y);
            }
            return null;
        }
        function calcUBoundsToFitTBounds(w, h, matrix, minX, minY, maxX, maxY) {
            var m = matrix.$data;
            var a = m[0 /* a */];
            var b = m[1 /* b */];
            var c = m[2 /* c */];
            var d = m[3 /* d */];
            if (-1.0e-9 < a && a < +1.0e-9)
                a = 0;
            if (-1.0e-9 < b && b < +1.0e-9)
                b = 0;
            if (-1.0e-9 < c && c < +1.0e-9)
                c = 0;
            if (-1.0e-9 < d && d < +1.0e-9)
                d = 0;
            if (b == 0 && c == 0) {
                if (a == 0 || d == 0)
                    return null;
                return lark.Point.create(w / Math.abs(a), h / Math.abs(d));
            }
            if (a == 0 && d == 0) {
                if (b == 0 || c == 0)
                    return null;
                return lark.Point.create(h / Math.abs(b), w / Math.abs(c));
            }
            var c1 = (a * c >= 0) ? c : -c;
            var d1 = (b * d >= 0) ? d : -d;
            var det = a * d1 - b * c1;
            if (Math.abs(det) < 1.0e-9) {
                if (c1 == 0 || a == 0 || a == -c1)
                    return null;
                if (Math.abs(a * h - b * w) > 1.0e-9)
                    return null;
                return solveEquation(a, c1, w, minX, minX, maxX, maxY, b, d1);
            }
            var invDet = 1 / det;
            w *= invDet;
            h *= invDet;
            var s;
            s = solveSystem(a, c1, b, d1, w, h);
            if (s && minX <= s.x && s.x <= maxX && minY <= s.y && s.y <= maxY && a * s.x + c1 * s.x >= 0 && b * s.x + d1 * s.y >= 0)
                return s;
            s = solveSystem(a, c1, b, d1, w, -h);
            if (s && minX <= s.x && s.x <= maxX && minY <= s.y && s.y <= maxY && a * s.x + c1 * s.x >= 0 && b * s.x + d1 * s.y < 0)
                return s;
            s = solveSystem(a, c1, b, d1, -w, h);
            if (s && minX <= s.x && s.x <= maxX && minY <= s.y && s.y <= maxY && a * s.x + c1 * s.x < 0 && b * s.x + d1 * s.y >= 0)
                return s;
            s = solveSystem(a, c1, b, d1, -w, -h);
            if (s && minX <= s.x && s.x <= maxX && minY <= s.y && s.y <= maxY && a * s.x + c1 * s.x < 0 && b * s.x + d1 * s.y < 0)
                return s;
            lark.Point.release(s);
            return null;
        }
        function transformSize(width, height, matrix) {
            var bounds = lark.$TempRectangle.setTo(0, 0, width, height);
            matrix.$transformBounds(bounds);
            return bounds;
        }
        function solveSystem(a, c, b, d, mOverDet, nOverDet) {
            return lark.Point.create(d * mOverDet - c * nOverDet, a * nOverDet - b * mOverDet);
        }
    })(player = lark.player || (lark.player = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * State 类定义视图状态，即组件的特定视图。
         */
        var State = (function (_super) {
            __extends(State, _super);
            /**
             * 创建一个State实例
             */
            function State(name, overrides) {
                _super.call(this);
                this.name = name;
                this.overrides = overrides;
            }var d = __define,c=State;p=c.prototype;
            return State;
        })(lark.LarkObject);
        gui.State = State;
        State.prototype.__class__ = "lark.gui.State";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 失效验证管理器
         */
        var Validator = (function (_super) {
            __extends(Validator, _super);
            /**
             * 创建一个Validator对象
             */
            function Validator() {
                _super.call(this);
                this.targetLevel = Number.POSITIVE_INFINITY;
                this.invalidatePropertiesFlag = false;
                this.invalidateClientPropertiesFlag = false;
                this.invalidatePropertiesQueue = new DepthQueue();
                this.invalidateSizeFlag = false;
                this.invalidateClientSizeFlag = false;
                this.invalidateSizeQueue = new DepthQueue();
                this.invalidateDisplayListFlag = false;
                this.invalidateDisplayListQueue = new DepthQueue();
                this.eventDisplay = new lark.Bitmap();
                /**
                 * 是否已经添加了事件监听
                 */
                this.listenersAttached = false;
            }var d = __define,c=Validator;p=c.prototype;
            /**
             * 标记组件属性失效
             */
            p.invalidateProperties = function (client) {
                if (!this.invalidatePropertiesFlag) {
                    this.invalidatePropertiesFlag = true;
                    if (!this.listenersAttached)
                        this.attachListeners();
                }
                if (this.targetLevel <= client.$nestLevel)
                    this.invalidateClientPropertiesFlag = true;
                this.invalidatePropertiesQueue.insert(client);
            };
            /**
             * 验证失效的属性
             */
            p.validateProperties = function () {
                var queue = this.invalidatePropertiesQueue;
                var client = queue.shift();
                while (client) {
                    if (client.$stage) {
                        client.validateProperties();
                    }
                    client = queue.shift();
                }
                if (queue.isEmpty())
                    this.invalidatePropertiesFlag = false;
            };
            /**
             * 标记需要重新测量尺寸
             */
            p.invalidateSize = function (client) {
                if (!this.invalidateSizeFlag) {
                    this.invalidateSizeFlag = true;
                    if (!this.listenersAttached)
                        this.attachListeners();
                }
                if (this.targetLevel <= client.$nestLevel)
                    this.invalidateClientSizeFlag = true;
                this.invalidateSizeQueue.insert(client);
            };
            /**
             * 测量尺寸
             */
            p.validateSize = function () {
                var queue = this.invalidateSizeQueue;
                var client = queue.pop();
                while (client) {
                    if (client.$stage) {
                        client.validateSize();
                    }
                    client = queue.pop();
                }
                if (queue.isEmpty())
                    this.invalidateSizeFlag = false;
            };
            /**
             * 标记需要重新布局
             */
            p.invalidateDisplayList = function (client) {
                if (!this.invalidateDisplayListFlag) {
                    this.invalidateDisplayListFlag = true;
                    if (!this.listenersAttached)
                        this.attachListeners();
                }
                this.invalidateDisplayListQueue.insert(client);
            };
            /**
             * 重新布局
             */
            p.validateDisplayList = function () {
                var queue = this.invalidateDisplayListQueue;
                var client = queue.shift();
                while (client) {
                    if (client.$stage) {
                        client.validateDisplayList();
                    }
                    client = queue.shift();
                }
                if (queue.isEmpty())
                    this.invalidateDisplayListFlag = false;
            };
            /**
             * 添加事件监听
             */
            p.attachListeners = function () {
                this.eventDisplay.on(lark.Event.ENTER_FRAME, this.doPhasedInstantiationCallBack, this);
                this.eventDisplay.on(lark.Event.RENDER, this.doPhasedInstantiationCallBack, this);
                lark.player.Ticker.$invalidateRenderFlag = true;
                this.listenersAttached = true;
            };
            /**
             * 执行属性应用
             */
            p.doPhasedInstantiationCallBack = function (event) {
                this.eventDisplay.removeListener(lark.Event.ENTER_FRAME, this.doPhasedInstantiationCallBack, this);
                this.eventDisplay.removeListener(lark.Event.RENDER, this.doPhasedInstantiationCallBack, this);
                this.doPhasedInstantiation();
            };
            p.doPhasedInstantiation = function () {
                if (this.invalidatePropertiesFlag) {
                    this.validateProperties();
                }
                if (this.invalidateSizeFlag) {
                    this.validateSize();
                }
                if (this.invalidateDisplayListFlag) {
                    this.validateDisplayList();
                }
                if (this.invalidatePropertiesFlag || this.invalidateSizeFlag || this.invalidateDisplayListFlag) {
                    this.attachListeners();
                }
                else {
                    this.listenersAttached = false;
                }
            };
            /**
             * 使大于等于指定组件层级的元素立即应用属性
             * @param target 要立即应用属性的组件
             */
            p.validateClient = function (target) {
                var obj;
                var done = false;
                var oldTargetLevel = this.targetLevel;
                if (this.targetLevel === Number.POSITIVE_INFINITY)
                    this.targetLevel = target.$nestLevel;
                var propertiesQueue = this.invalidatePropertiesQueue;
                var sizeQueue = this.invalidateSizeQueue;
                var displayListQueue = this.invalidateDisplayListQueue;
                while (!done) {
                    done = true;
                    obj = propertiesQueue.removeSmallestChild(target);
                    while (obj) {
                        if (obj.$stage) {
                            obj.validateProperties();
                        }
                        obj = propertiesQueue.removeSmallestChild(target);
                    }
                    if (propertiesQueue.isEmpty()) {
                        this.invalidatePropertiesFlag = false;
                    }
                    this.invalidateClientPropertiesFlag = false;
                    obj = sizeQueue.removeLargestChild(target);
                    while (obj) {
                        if (obj.$stage) {
                            obj.validateSize();
                        }
                        if (this.invalidateClientPropertiesFlag) {
                            obj = (propertiesQueue.removeSmallestChild(target));
                            if (obj) {
                                propertiesQueue.insert(obj);
                                done = false;
                                break;
                            }
                        }
                        obj = sizeQueue.removeLargestChild(target);
                    }
                    if (sizeQueue.isEmpty()) {
                        this.invalidateSizeFlag = false;
                    }
                    this.invalidateClientPropertiesFlag = false;
                    this.invalidateClientSizeFlag = false;
                    obj = displayListQueue.removeSmallestChild(target);
                    while (obj) {
                        if (obj.$stage) {
                            obj.validateDisplayList();
                        }
                        if (this.invalidateClientPropertiesFlag) {
                            obj = propertiesQueue.removeSmallestChild(target);
                            if (obj) {
                                propertiesQueue.insert(obj);
                                done = false;
                                break;
                            }
                        }
                        if (this.invalidateClientSizeFlag) {
                            obj = sizeQueue.removeLargestChild(target);
                            if (obj) {
                                sizeQueue.insert(obj);
                                done = false;
                                break;
                            }
                        }
                        obj = displayListQueue.removeSmallestChild(target);
                    }
                    if (displayListQueue.isEmpty()) {
                        this.invalidateDisplayListFlag = false;
                    }
                }
                if (oldTargetLevel === Number.POSITIVE_INFINITY) {
                    this.targetLevel = Number.POSITIVE_INFINITY;
                }
            };
            return Validator;
        })(lark.EventEmitter);
        gui.Validator = Validator;
        Validator.prototype.__class__ = "lark.gui.Validator";
        /**
         * 显示列表嵌套深度排序队列
         */
        var DepthQueue = (function () {
            function DepthQueue() {
                /**
                 * 深度队列
                 */
                this.depthBins = {};
                /**
                 * 最小深度
                 */
                this.minDepth = 0;
                /**
                 * 最大深度
                 */
                this.maxDepth = -1;
            }var d = __define,c=DepthQueue;p=c.prototype;
            /**
             * 插入一个元素
             */
            p.insert = function (client) {
                var depth = client.$nestLevel;
                if (this.maxDepth < this.minDepth) {
                    this.minDepth = this.maxDepth = depth;
                }
                else {
                    if (depth < this.minDepth)
                        this.minDepth = depth;
                    if (depth > this.maxDepth)
                        this.maxDepth = depth;
                }
                var bin = this.depthBins[depth];
                if (!bin) {
                    bin = this.depthBins[depth] = new DepthBin();
                }
                bin.insert(client);
            };
            /**
             * 从队列尾弹出深度最大的一个对象
             */
            p.pop = function () {
                var client;
                var minDepth = this.minDepth;
                if (minDepth <= this.maxDepth) {
                    var bin = this.depthBins[this.maxDepth];
                    while (!bin || bin.length === 0) {
                        this.maxDepth--;
                        if (this.maxDepth < minDepth)
                            return null;
                        bin = this.depthBins[this.maxDepth];
                    }
                    client = bin.shift();
                    while (!bin || bin.length == 0) {
                        this.maxDepth--;
                        if (this.maxDepth < minDepth)
                            break;
                        bin = this.depthBins[this.maxDepth];
                    }
                }
                return client;
            };
            /**
             * 从队列首弹出深度最小的一个对象
             */
            p.shift = function () {
                var client;
                var maxDepth = this.maxDepth;
                if (this.minDepth <= maxDepth) {
                    var bin = this.depthBins[this.minDepth];
                    while (!bin || bin.length === 0) {
                        this.minDepth++;
                        if (this.minDepth > maxDepth)
                            return null;
                        bin = this.depthBins[this.minDepth];
                    }
                    client = bin.shift();
                    while (!bin || bin.length == 0) {
                        this.minDepth++;
                        if (this.minDepth > maxDepth)
                            break;
                        bin = this.depthBins[this.minDepth];
                    }
                }
                return client;
            };
            /**
             * 移除大于等于指定组件层级的元素中最大的元素
             */
            p.removeLargestChild = function (client) {
                var hashCode = client.$hashCode;
                var nestLevel = client.$nestLevel;
                var max = this.maxDepth;
                var min = nestLevel;
                while (min <= max) {
                    var bin = this.depthBins[max];
                    if (bin && bin.length > 0) {
                        if (max === nestLevel) {
                            if (bin.map[hashCode]) {
                                bin.remove(client);
                                return client;
                            }
                        }
                        else if (lark.is(client, 4 /* DisplayObjectContainer */)) {
                            var items = bin.items;
                            var length = bin.length;
                            for (var i = 0; i < length; i++) {
                                var value = items[i];
                                if (client.contains(value)) {
                                    bin.remove(value);
                                    return value;
                                }
                            }
                        }
                        else {
                            break;
                        }
                        max--;
                    }
                    else {
                        if (max == this.maxDepth) {
                            this.maxDepth--;
                        }
                        max--;
                        if (max < min)
                            break;
                    }
                }
                return null;
            };
            /**
             * 移除大于等于指定组件层级的元素中最小的元素
             */
            p.removeSmallestChild = function (client) {
                var nestLevel = client.$nestLevel;
                var min = nestLevel;
                var max = this.maxDepth;
                var hashCode = client.$hashCode;
                while (min <= max) {
                    var bin = this.depthBins[min];
                    if (bin && bin.length > 0) {
                        if (min === nestLevel) {
                            if (bin.map[hashCode]) {
                                bin.remove(client);
                                return client;
                            }
                        }
                        else if (lark.is(client, 4 /* DisplayObjectContainer */)) {
                            var items = bin.items;
                            var length = bin.length;
                            for (var i = 0; i < length; i++) {
                                var value = items[i];
                                if (client.contains(value)) {
                                    bin.remove(value);
                                    return value;
                                }
                            }
                        }
                        else {
                            break;
                        }
                        min++;
                    }
                    else {
                        if (min == this.minDepth)
                            this.minDepth++;
                        min++;
                        if (min > max)
                            break;
                    }
                }
                return null;
            };
            /**
             * 队列是否为空
             */
            p.isEmpty = function () {
                return this.minDepth > this.maxDepth;
            };
            return DepthQueue;
        })();
        DepthQueue.prototype.__class__ = "lark.gui.DepthQueue";
        /**
         * 列表项
         */
        var DepthBin = (function () {
            function DepthBin() {
                this.map = {};
                this.items = [];
                this.length = 0;
            }var d = __define,c=DepthBin;p=c.prototype;
            p.insert = function (client) {
                var hashCode = client.$hashCode;
                if (this.map[hashCode]) {
                    return;
                }
                this.map[hashCode] = true;
                this.length++;
                this.items.push(client);
            };
            p.shift = function () {
                var client = this.items.shift();
                if (client) {
                    this.map[client.$hashCode] = false;
                    this.length--;
                }
                return client;
            };
            p.remove = function (client) {
                var index = this.items.indexOf(client);
                if (index >= 0) {
                    this.items.splice(index, 1);
                    this.map[client.$hashCode] = false;
                    this.length--;
                }
            };
            return DepthBin;
        })();
        DepthBin.prototype.__class__ = "lark.gui.DepthBin";
        gui.validator = new Validator();
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 皮肤主题。实例化一个主题，能够在运行时修改全局的默认皮肤。
         */
        var Theme = (function (_super) {
            __extends(Theme, _super);
            function Theme(stage) {
                _super.call(this);
                this.skinMap = {};
                this.flagToClassName = {};
                if (DEBUG && !stage) {
                    lark.$error(1003, "stage");
                }
                Theme.themeMap[stage.$hashCode] = this;
            }var d = __define,c=Theme;p=c.prototype;
            /**
             * 获取组件对应的默认皮肤。
             */
            Theme.$getDefaultSkin = function (client, stage) {
                var theme = Theme.themeMap[stage.$hashCode];
                if (!theme) {
                    return null;
                }
                return theme.getSkin(client);
            };
            /**
             * 根据主机组件，获取对应的默认皮肤实例。
             * @param client 要获取默认皮肤的组件
             */
            p.getSkin = function (client) {
                return null;
            };
            /**
             * 为指定的主机组件映射一个默认皮肤
             * @param hostComponentKey 主机组件名称，例如：“lark.gui.Button”
             * @param skinName 皮肤名称 例如："app.MyButtonSkin";
             */
            p.mapSkin = function (hostComponentKey, skinName) {
                if (DEBUG) {
                    if (!hostComponentKey) {
                        lark.$error(1003, "hostComponentKey");
                    }
                    if (!skinName) {
                        lark.$error(1003, "skinName");
                    }
                }
                this.skinMap[hostComponentKey] = skinName;
                var clazz = lark.getDefinitionByName(hostComponentKey);
                if (clazz && clazz.prototype) {
                    var flag = clazz.prototype.__classFlag__;
                    if (flag) {
                        this.flagToClassName[flag] = hostComponentKey;
                    }
                }
            };
            Theme.themeMap = {};
            return Theme;
        })(lark.EventEmitter);
        gui.Theme = Theme;
        Theme.prototype.__class__ = "lark.gui.Theme";
        lark.registerClass(Theme, 1007 /* Theme */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 容器布局基类。若要创建使用 Group 容器的自定义布局，必须扩展 LayoutBase 或其子类之一。
         * 子类必须实现 updateDisplayList() 方法（定位 target Group 的子项并调整这些子项的大小）和 measure() 方法（计算 target 的默认大小）。
         */
        var LayoutBase = (function (_super) {
            __extends(LayoutBase, _super);
            function LayoutBase() {
                _super.call(this);
                this.$target = null;
                this.$useVirtualLayout = false;
                this._typicalLayoutRect = null;
            }var d = __define,c=LayoutBase;p=c.prototype;
            d(p, "target", {
                /**
                 * 目标容器
                 */
                g: function () {
                    return this.$target;
                },
                s: function (value) {
                    if (this.$target === value)
                        return;
                    this.$target = value;
                    this.clearVirtualLayoutCache();
                },
            });
            d(p, "useVirtualLayout", {
                /**
                 * 若要配置容器使用虚拟布局，请为与容器关联的布局的 useVirtualLayout 属性设置为 true。
                 * 只有布局设置为 VerticalLayout、HorizontalLayout
                 * 或 TileLayout 的 DataGroup 或 SkinnableDataContainer
                 * 才支持虚拟布局。不支持虚拟化的布局子类必须禁止更改此属性。
                 */
                g: function () {
                    return this.$useVirtualLayout;
                },
                s: function (value) {
                    if (this.$useVirtualLayout == value)
                        return;
                    this.$useVirtualLayout = value;
                    this.emitWith("useVirtualLayoutChanged");
                    if (this.$useVirtualLayout && !value)
                        this.clearVirtualLayoutCache();
                    if (this.target)
                        this.target.invalidateDisplayList();
                },
            });
            d(p, "typicalLayoutRect", {
                /**
                 * 由虚拟布局所使用，以估计尚未滚动到视图中的布局元素的大小。
                 */
                g: function () {
                    return this._typicalLayoutRect;
                },
                s: function (value) {
                    if (this._typicalLayoutRect == value)
                        return;
                    this._typicalLayoutRect = value;
                    if (this.target)
                        this.target.invalidateSize();
                },
            });
            /**
             * 滚动条位置改变
             */
            p.scrollPositionChanged = function () {
            };
            /**
             * 清理虚拟布局缓存的数据
             */
            p.clearVirtualLayoutCache = function () {
            };
            /**
             * 在已添加布局元素之后且在验证目标的大小和显示列表之前，由目标调用。
             * 按元素状态缓存的布局（比如虚拟布局）可以覆盖此方法以更新其缓存。
             * @param index 发生改变的子项索引
             */
            p.elementAdded = function (index) {
            };
            /**
             * 必须在已删除布局元素之后且在验证目标的大小和显示列表之前，由目标调用此方法。
             * 按元素状态缓存的布局（比如虚拟布局）可以覆盖此方法以更新其缓存。
             * @param index 发生改变的子项索引
             */
            p.elementRemoved = function (index) {
            };
            /**
             * 测量组件尺寸大小
             */
            p.measure = function () {
            };
            /**
             * 更新显示列表
             */
            p.updateDisplayList = function (width, height) {
            };
            return LayoutBase;
        })(lark.EventEmitter);
        gui.LayoutBase = LayoutBase;
        LayoutBase.prototype.__class__ = "lark.gui.LayoutBase";
        lark.registerClass(LayoutBase, 1009 /* LayoutBase */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * UI事件
         */
        var UIEvent = (function (_super) {
            __extends(UIEvent, _super);
            function UIEvent(type, bubbles, cancelable) {
                _super.call(this, type, bubbles, cancelable);
            }var d = __define,c=UIEvent;p=c.prototype;
            /**
             * 使用指定的EventEmitter对象来抛出事件对象。抛出的对象将会缓存在对象池上，供下次循环复用。
             * @param target 事件派发目标
             * @param eventType 事件类型
             */
            UIEvent.emitUIEvent = function (target, eventType) {
                if (!target.hasListener(eventType)) {
                    return;
                }
                var event = lark.Event.create(UIEvent, eventType);
                var result = target.emit(event);
                lark.Event.release(event);
                return result;
            };
            /**
             * 改变结束
             */
            UIEvent.CHANGE_END = "changeEnd";
            /**
             * 改变开始
             */
            UIEvent.CHANGE_START = "changeStart";
            /**
             * 正在改变中
             */
            UIEvent.CHANGING = "changing";
            /**
             * 值发生改变
             */
            UIEvent.VALUE_COMMIT = "valueCommit";
            /**
             * Component皮肤发生改变
             */
            UIEvent.SKIN_CHANGED = "skinChanged";
            /**
             * 容器的内容尺寸发生改变
             */
            UIEvent.CONTENT_SIZE_CHANGED = "contentSizeChanged";
            /**
             * 容器的滚动位置发生改变
             */
            UIEvent.SCROLL_POSITION_CHANGED = "scrollPositionChanged";
            /**
             * 即将关闭面板事件
             */
            UIEvent.CLOSING = "close";
            return UIEvent;
        })(lark.Event);
        gui.UIEvent = UIEvent;
        UIEvent.prototype.__class__ = "lark.gui.UIEvent";
        lark.registerClass(UIEvent, 1008 /* UIEvent */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 皮肤基类。通常情况下，您不需要手动创建这个类的实例，而是通过解析EXML文件后自动生成。
         */
        var Skin = (function (_super) {
            __extends(Skin, _super);
            function Skin() {
                _super.apply(this, arguments);
                /**
                 * 皮肤的最大宽度。仅影响主机组件的测量结果。
                 */
                this.maxWidth = 100000;
                /**
                 * 皮肤的最小宽度,此属性设置为大于maxWidth的值时无效。仅影响主机组件的测量结果。
                 */
                this.minWidth = 0;
                /**
                 * 皮肤的最大高度。仅影响主机组件的测量结果。
                 */
                this.maxHeight = 100000;
                /**
                 * 皮肤的最小高度,此属性设置为大于maxHeight的值时无效。仅影响主机组件的测量结果。
                 */
                this.minHeight = 0;
                /**
                 * 皮肤显式设置宽度,设置为NONE表示不显式设置。仅影响主机组件的测量结果。
                 */
                this.width = lark.NONE;
                /**
                 * 皮肤显式设置高度,设置为NONE表示不显式设置。仅影响主机组件的测量结果。
                 */
                this.height = lark.NONE;
                this.$elementsContent = [];
                this._hostComponent = null;
                //========================state相关函数===============start=========================
                this.statesMap = {};
                this._states = [];
                /**
                 * 当前视图状态发生改变的标志
                 */
                this.currentStateChanged = false;
                this._currentState = null;
                /**
                 * 存储还未验证的视图状态
                 */
                this.requestedCurrentState = null;
            }var d = __define,c=Skin;p=c.prototype;
            d(p, "elementsContent", {
                s: function (value) {
                    this.$elementsContent = value;
                },
            });
            d(p, "hostComponent", {
                /**
                 * 此皮肤附加到的主机组件
                 */
                g: function () {
                    return this._hostComponent;
                },
                s: function (value) {
                    if (this._hostComponent == value)
                        return;
                    this._hostComponent = value;
                    if (this._hostComponent) {
                        if (this.currentStateChanged) {
                            this.commitCurrentState();
                        }
                    }
                },
            });
            d(p, "states", {
                /**
                 * 为此组件定义的视图状态。
                 */
                g: function () {
                    return this._states;
                },
                s: function (value) {
                    if (!value)
                        value = [];
                    this._states = value;
                    var statesMap = {};
                    var length = value.length;
                    for (var i = 0; i < length; i++) {
                        var state = value[i];
                        statesMap[state.name] = state;
                    }
                    this.statesMap = statesMap;
                    this.currentStateChanged = true;
                    this.requestedCurrentState = this._currentState;
                    if (!this.hasState(this.requestedCurrentState)) {
                        this.requestedCurrentState = this.getDefaultState();
                    }
                    if (this._hostComponent) {
                        this.commitCurrentState();
                    }
                },
            });
            d(p, "currentState", {
                /**
                 * 组件的当前视图状态。将其设置为 "" 或 null 可将组件重置回其基本状态。
                 */
                g: function () {
                    return this.currentStateChanged ? this.requestedCurrentState : this._currentState;
                },
                s: function (value) {
                    if (value != this.currentState) {
                        this.requestedCurrentState = value;
                        this.currentStateChanged = true;
                        if (this._hostComponent) {
                            this.commitCurrentState();
                        }
                    }
                },
            });
            /**
             * 返回默认状态
             */
            p.getDefaultState = function () {
                if (this._states.length > 0) {
                    return this._states[0].name;
                }
                return null;
            };
            /**
             * 应用当前的视图状态。子类覆盖此方法在视图状态发生改变时执行相应更新操作。
             */
            p.commitCurrentState = function () {
                if (!this.currentStateChanged)
                    return;
                this.currentStateChanged = false;
                var destination = this.statesMap[this.requestedCurrentState];
                if (!destination) {
                    this.requestedCurrentState = this.getDefaultState();
                }
                this.removeState(this._currentState);
                this._currentState = this.requestedCurrentState;
                this.applyState(this._currentState);
            };
            /**
             * 返回是否含有指定名称的视图状态
             * @param stateName 要检查的视图状态名称
             */
            p.hasState = function (stateName) {
                return !!this.statesMap[stateName];
            };
            /**
             * 移除指定的视图状态以及所依赖的所有父级状态，除了与新状态的共同状态外
             */
            p.removeState = function (stateName) {
                var state = this.statesMap[stateName];
                if (state) {
                    var overrides = state.overrides;
                    for (var i = overrides.length - 1; i >= 0; i--)
                        overrides[i].remove(this);
                }
            };
            /**
             * 应用新状态
             */
            p.applyState = function (stateName) {
                var state = this.statesMap[stateName];
                if (state) {
                    var overrides = state.overrides;
                    var length = overrides.length;
                    for (var i = 0; i < length; i++)
                        overrides[i].apply(this);
                }
            };
            return Skin;
        })(lark.LarkObject);
        gui.Skin = Skin;
        Skin.prototype.__class__ = "lark.gui.Skin";
        lark.registerClass(Skin, 1006 /* Skin */);
        gui.registerProperty(Skin, "elementsContent", "Array", true);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var player;
    (function (player) {
        /**
         * EXML配置管理器实例
         */
        player.exmlConfig;
        var exmlParserPool = [];
        var innerClassCount = 1;
        var DECLARATIONS = "Declarations";
        var RECTANGLE = "lark.Rectangle";
        var IFACTORY = "lark.gui.IFactory";
        var CLASS_FACTORY = "lark.gui.ClassFactory";
        var ELEMENTS_CONTENT = "elementsContent";
        var basicTypes = ["Array", "boolean", "string", "number"];
        var wingKeys = ["id", "locked", "includeIn", "excludeFrom"];
        var htmlEntities = [["<", "&lt;"], [">", "&gt;"], ["&", "&amp;"], ["\"", "&quot;"], ["'", "&apos;"]];
        var EXMLParser = (function () {
            function EXMLParser() {
                /**
                 * 延迟赋值字典
                 */
                this.delayAssignmentDic = {};
                if (DEBUG) {
                    this.repeatedIdMap = {};
                    this.getRepeatedIds = getRepeatedIds;
                    this.getIds = getIds;
                    this.checkDeclarations = checkDeclarations;
                }
            }var d = __define,c=EXMLParser;p=c.prototype;
            /**
             * 编译指定的XML对象为JavaScript代码。
             * @param xmlData 要编译的EXML文件内容
             * @param className 要编译成的完整类名，包括模块名。
             */
            p.parse = function (xmlData, className) {
                var clazz = this.parseClass(xmlData, className);
                return clazz.toCode();
            };
            /**
             * 编译指定的XML对象为CpClass对象。
             */
            p.parseClass = function (xmlData, className) {
                if (!player.exmlConfig) {
                    player.exmlConfig = new player.EXMLConfig();
                }
                this.currentXML = xmlData;
                this.currentClassName = className;
                this.delayAssignmentDic = {};
                this.idDic = {};
                this.idToNode = {};
                this.stateCode = [];
                this.stateNames = [];
                this.skinParts = [];
                this.declarations = null;
                this.currentClass = new player.CpClass();
                this.stateIds = [];
                var index = className.lastIndexOf(".");
                if (index != -1) {
                    this.currentClass.className = className.substring(index + 1);
                }
                else {
                    this.currentClass.className = className;
                }
                this.startCompile();
                var clazz = this.currentClass;
                this.currentClass = null;
                return clazz;
            };
            /**
             * 开始编译
             */
            p.startCompile = function () {
                if (DEBUG) {
                    var result = this.getRepeatedIds(this.currentXML);
                    if (result.length > 0) {
                        lark.$error(2004, this.currentClassName, result.join("\n"));
                    }
                }
                this.currentClass.superClass = this.getClassNameOfNode(this.currentXML);
                this.getStateNames();
                var children = this.currentXML.children;
                if (children) {
                    var length = children.length;
                    for (var i = 0; i < length; i++) {
                        var node = children[i];
                        if (node.nodeType === 1 && node.namespace == player.NS_W && node.localName == DECLARATIONS) {
                            this.declarations = node;
                            break;
                        }
                    }
                }
                if (DEBUG) {
                    var list = [];
                    this.checkDeclarations(this.declarations, list);
                    if (list.length > 0) {
                        lark.$error(2020, this.currentClassName, list.join("\n"));
                    }
                }
                if (!this.currentXML.namespace) {
                    if (DEBUG) {
                        lark.$error(2017, this.currentClassName, toXMLString(this.currentXML));
                    }
                    return;
                }
                this.addIds(this.currentXML.children, this.currentClass.superClass);
                this.createConstructFunc();
            };
            /**
             * 添加必须的id
             */
            p.addIds = function (items, className) {
                if (!items) {
                    return;
                }
                var length = items.length;
                for (var i = 0; i < length; i++) {
                    var node = items[i];
                    if (node.nodeType != 1) {
                        continue;
                    }
                    if (!node.namespace) {
                        if (DEBUG) {
                            lark.$error(2017, this.currentClassName, toXMLString(node));
                        }
                        continue;
                    }
                    if (node.localName == "Skin" && node.namespace == player.NS_E) {
                        continue;
                    }
                    var nodeClassName = this.getClassNameOfNode(node);
                    this.addIds(node.children, nodeClassName);
                    var id = node.attributes["id"];
                    if (node.namespace == player.NS_W) {
                    }
                    else if (id) {
                        this.idToNode[id] = node;
                        if (this.skinParts.indexOf(id) == -1) {
                            this.skinParts.push(id);
                        }
                        this.createVarForNode(node);
                        if (this.isStateNode(node))
                            this.stateIds.push(id);
                    }
                    else if (node.localName) {
                        if (this.isProperty(node, className)) {
                            var prop = node.localName;
                            var index = prop.indexOf(".");
                            var children = node.children;
                            if (index == -1 || !children || children.length == 0) {
                                continue;
                            }
                            var firstChild = children[0];
                            this.stateIds.push(firstChild.attributes.id);
                        }
                        else {
                            this.createIdForNode(node);
                            this.idToNode[node.attributes.id] = node;
                            if (this.isStateNode(node))
                                this.stateIds.push(node.attributes.id);
                        }
                    }
                }
            };
            /**
             * 检测指定节点的属性是否含有视图状态
             */
            p.containsState = function (node) {
                var attributes = node.attributes;
                if (attributes["includeIn"] || attributes["$excludeFrom"]) {
                    return true;
                }
                var keys = Object.keys(attributes);
                var length = keys.length;
                for (var i = 0; i < length; i++) {
                    var name = keys[i];
                    if (name.indexOf(".") != -1) {
                        return true;
                    }
                }
                return false;
            };
            /**
             * 为指定节点创建id属性
             */
            p.createIdForNode = function (node) {
                var idName = this.getNodeId(node);
                if (!this.idDic[idName])
                    this.idDic[idName] = 1;
                else
                    this.idDic[idName]++;
                idName += this.idDic[idName];
                node.attributes.id = idName;
            };
            /**
             * 获取节点ID
             */
            p.getNodeId = function (node) {
                if (node.attributes["id"])
                    return node.attributes.id;
                return "_" + node.localName;
            };
            /**
             * 为指定节点创建变量
             */
            p.createVarForNode = function (node) {
                var moduleName = this.getClassNameOfNode(node);
                if (moduleName == "")
                    return;
                if (!this.currentClass.getVariableByName(node.attributes.id))
                    this.currentClass.addVariable(new player.CpVariable(node.attributes.id));
            };
            /**
             * 为指定节点创建初始化函数,返回函数名引用
             */
            p.createFuncForNode = function (node) {
                var className = node.localName;
                var isBasicType = this.isBasicTypeData(className);
                if (isBasicType)
                    return this.createBasicTypeForNode(node);
                var moduleName = this.getClassNameOfNode(node);
                var func = new player.CpFunction();
                var tailName = "_i";
                var id = node.attributes.id;
                func.name = id + tailName;
                var cb = new player.CpCodeBlock();
                var varName = "t";
                if (className == "Object") {
                    cb.addVar(varName, "{}");
                }
                else {
                    cb.addVar(varName, "new " + moduleName + "()");
                }
                var containsId = !!this.currentClass.getVariableByName(id);
                if (containsId) {
                    cb.addAssignment("this." + id, varName);
                }
                this.addAttributesToCodeBlock(cb, varName, node);
                this.initlizeChildNode(node, cb, varName);
                var delayAssignments = this.delayAssignmentDic[id];
                if (delayAssignments) {
                    var length = delayAssignments.length;
                    for (var i = 0; i < length; i++) {
                        var codeBlock = delayAssignments[i];
                        cb.concat(codeBlock);
                    }
                }
                cb.addReturn(varName);
                func.codeBlock = cb;
                this.currentClass.addFunction(func);
                return "this." + func.name + "()";
            };
            /**
             * 检查目标类名是否是基本数据类型
             */
            p.isBasicTypeData = function (className) {
                return basicTypes.indexOf(className) != -1;
            };
            /**
             * 为指定基本数据类型节点实例化,返回实例化后的值。
             */
            p.createBasicTypeForNode = function (node) {
                var className = node.localName;
                var returnValue = "";
                var varItem = this.currentClass.getVariableByName(node.attributes.id);
                var children = node.children;
                var text = "";
                if (children && children.length > 0) {
                    var firstChild = children[0];
                    if (firstChild.nodeType == 3) {
                        text = firstChild.text.trim();
                    }
                }
                switch (className) {
                    case "Array":
                        var values = [];
                        if (children) {
                            var length = children.length;
                            for (var i = 0; i < length; i++) {
                                var child = children[i];
                                if (child.nodeType == 1) {
                                    values.push(this.createFuncForNode(child));
                                }
                            }
                        }
                        returnValue = "[" + values.join(",") + "]";
                        break;
                    case "boolean":
                        returnValue = (text == "false" || !text) ? "false" : "true";
                        break;
                    case "number":
                        returnValue = text;
                        if (returnValue.indexOf("%") != -1)
                            returnValue = returnValue.substring(0, returnValue.length - 1);
                        break;
                    case "string":
                        returnValue = this.formatString(text);
                        break;
                }
                if (varItem)
                    varItem.defaultValue = returnValue;
                return returnValue;
            };
            /**
             * 将节点属性赋值语句添加到代码块
             */
            p.addAttributesToCodeBlock = function (cb, varName, node) {
                var key;
                var value;
                var attributes = node.attributes;
                var keyList = Object.keys(attributes);
                keyList.sort(); //排序一下防止出现随机顺序
                var length = keyList.length;
                for (var i = 0; i < length; i++) {
                    key = keyList[i];
                    if (!this.isNormalKey(key)) {
                        continue;
                    }
                    value = attributes[key];
                    key = this.formatKey(key, value);
                    value = this.formatValue(key, value, node);
                    if (!value) {
                        continue;
                    }
                    if (this.currentClass.getVariableByName(value)) {
                        var id = attributes.id;
                        var codeLine = "this." + id + " = t;";
                        if (!this.currentClass.getVariableByName(id))
                            this.createVarForNode(node);
                        if (!cb.containsCodeLine(codeLine)) {
                            cb.addCodeLineAt(codeLine, 1);
                        }
                        var delayCb = new player.CpCodeBlock();
                        if (varName == "this") {
                            delayCb.addAssignment(varName, "this." + value, key);
                        }
                        else {
                            delayCb.startIf("this." + id);
                            delayCb.addAssignment("this." + id, "this." + value, key);
                            delayCb.endBlock();
                        }
                        if (!this.delayAssignmentDic[value]) {
                            this.delayAssignmentDic[value] = [];
                        }
                        this.delayAssignmentDic[value].push(delayCb);
                        value = "this." + value;
                    }
                    cb.addAssignment(varName, value, key);
                }
            };
            /**
             * 初始化子项
             */
            p.initlizeChildNode = function (node, cb, varName) {
                var children = node.children;
                if (!children || children.length == 0)
                    return;
                var className = player.exmlConfig.getClassNameById(node.localName, node.namespace);
                var directChild = [];
                var length = children.length;
                var propList = [];
                for (var i = 0; i < length; i++) {
                    var child = children[i];
                    if (child.nodeType != 1 || child.namespace == player.NS_W) {
                        continue;
                    }
                    if (child.localName == "Skin" && child.namespace == player.NS_E) {
                        var parser = exmlParserPool.pop();
                        if (!parser) {
                            parser = new EXMLParser();
                        }
                        var innerClassName = this.currentClass.className + "$inner" + innerClassCount++;
                        var innerClass = parser.parseClass(child, innerClassName);
                        this.currentClass.addInnerClass(innerClass);
                        exmlParserPool.push(parser);
                        var type = player.exmlConfig.getPropertyType("skinName", className);
                        if (type) {
                            cb.addAssignment(varName, innerClassName, "skinName");
                        }
                        continue;
                    }
                    var prop = child.localName;
                    if (this.isProperty(child, className)) {
                        if (!this.isNormalKey(prop)) {
                            continue;
                        }
                        var type = player.exmlConfig.getPropertyType(child.localName, className);
                        if (!type) {
                            if (DEBUG) {
                                lark.$error(2005, this.currentClassName, child.localName, getPropertyStr(child));
                            }
                            continue;
                        }
                        if (!child.children || child.children.length == 0) {
                            if (DEBUG) {
                                lark.$warn(2102, this.currentClassName, getPropertyStr(child));
                            }
                            continue;
                        }
                        if (DEBUG) {
                            var errorInfo = getPropertyStr(child);
                        }
                        this.addChildrenToProp(child.children, type, prop, cb, varName, errorInfo, propList, node);
                    }
                    else {
                        directChild.push(child);
                    }
                }
                if (directChild.length == 0)
                    return;
                var defaultProp = player.exmlConfig.getDefaultPropById(node.localName, node.namespace);
                var defaultType = player.exmlConfig.getPropertyType(defaultProp, className);
                var errorInfo = getPropertyStr(directChild[0]);
                if (!defaultProp || !defaultType) {
                    if (DEBUG) {
                        lark.$error(2012, this.currentClassName, errorInfo);
                    }
                    return;
                }
                this.addChildrenToProp(directChild, defaultType, defaultProp, cb, varName, errorInfo, propList, node);
            };
            /**
             * 添加多个子节点到指定的属性
             */
            p.addChildrenToProp = function (children, type, prop, cb, varName, errorInfo, propList, node) {
                var childFunc = "";
                var childLength = children.length;
                if (childLength > 1) {
                    if (type != "Array") {
                        if (DEBUG) {
                            lark.$error(2011, this.currentClassName, prop, errorInfo);
                        }
                        return;
                    }
                    var values = [];
                    for (var j = 0; j < childLength; j++) {
                        var item = children[j];
                        if (item.nodeType != 1) {
                            continue;
                        }
                        childFunc = this.createFuncForNode(item);
                        var childClassName = this.getClassNameOfNode(item);
                        if (!this.isStateNode(item))
                            values.push(childFunc);
                    }
                    childFunc = "[" + values.join(",") + "]";
                }
                else {
                    var firstChild = children[0];
                    if (type == "Array") {
                        if (firstChild.localName == "Array") {
                            values = [];
                            if (firstChild.children) {
                                var len = firstChild.children.length;
                                for (var k = 0; k < len; k++) {
                                    item = firstChild.children[k];
                                    if (item.nodeType != 1) {
                                        continue;
                                    }
                                    childFunc = this.createFuncForNode(item);
                                    childClassName = this.getClassNameOfNode(item);
                                    if (!this.isStateNode(item))
                                        values.push(childFunc);
                                }
                            }
                            childFunc = "[" + values.join(",") + "]";
                        }
                        else {
                            childFunc = this.createFuncForNode(firstChild);
                            var childClassName = this.getClassNameOfNode(firstChild);
                            if (!this.isStateNode(firstChild))
                                childFunc = "[" + childFunc + "]";
                            else
                                childFunc = "[]";
                        }
                    }
                    else if (firstChild.nodeType == 1) {
                        var targetClass = this.getClassNameOfNode(firstChild);
                        childFunc = this.createFuncForNode(firstChild);
                    }
                    else {
                        childFunc = this.formatValue(prop, firstChild.text, node);
                    }
                }
                if (childFunc != "") {
                    if (childFunc.indexOf("()") == -1)
                        prop = this.formatKey(prop, childFunc);
                    if (propList.indexOf(prop) == -1) {
                        propList.push(prop);
                    }
                    else if (DEBUG) {
                        lark.$warn(2103, this.currentClassName, prop, errorInfo);
                    }
                    cb.addAssignment(varName, childFunc, prop);
                }
            };
            /**
             * 指定节点是否是属性节点
             */
            p.isProperty = function (node, className) {
                var name = node.localName;
                if (name == null)
                    return true;
                if (this.isBasicTypeData(name))
                    return false;
                var index = name.indexOf(".");
                if (index != -1) {
                    name = name.substr(0, index);
                }
                return !!player.exmlConfig.getPropertyType(name, className);
            };
            /**
             * 是否是普通赋值的key
             */
            p.isNormalKey = function (key) {
                if (!key || key.indexOf(".") != -1 || wingKeys.indexOf(key) != -1)
                    return false;
                return true;
            };
            /**
             * 格式化key
             */
            p.formatKey = function (key, value) {
                if (value.indexOf("%") != -1) {
                    if (key == "height")
                        key = "percentHeight";
                    else if (key == "width")
                        key = "percentWidth";
                }
                return key;
            };
            /**
             * 格式化值
             */
            p.formatValue = function (key, value, node) {
                if (!value) {
                    value = "";
                }
                var stringValue = value; //除了字符串，其他类型都去除两端多余空格。
                value = value.trim();
                var className = this.getClassNameOfNode(node);
                var type = player.exmlConfig.getPropertyType(key, className);
                if (DEBUG && !type) {
                    lark.$error(2005, this.currentClassName, key, toXMLString(node));
                }
                if (type != "string" && value.charAt(0) == "{" && value.charAt(value.length - 1) == "}") {
                    value = value.substr(1, value.length - 2);
                    value = value.trim();
                    if (value.indexOf("this.") == 0) {
                        value = value.substring(5);
                    }
                    var targetNode = this.idToNode[value];
                    if (DEBUG && !targetNode) {
                        lark.$error(2010, this.currentClassName, key, value, toXMLString(node));
                    }
                    var targetClass = this.getClassNameOfNode(targetNode);
                }
                else if (key == "scale9Grid" && type == RECTANGLE) {
                    if (DEBUG) {
                        var rect = value.split(",");
                        if (rect.length != 4 || isNaN(parseInt(rect[0])) || isNaN(parseInt(rect[1])) || isNaN(parseInt(rect[2])) || isNaN(parseInt(rect[3]))) {
                            lark.$error(2016, this.currentClassName, toXMLString(node));
                        }
                    }
                    value = "new " + RECTANGLE + "(" + value + ")";
                }
                else {
                    var orgValue = value;
                    switch (type) {
                        case IFACTORY:
                            value = "new " + CLASS_FACTORY + "(" + orgValue + ")";
                        case "number":
                            if (value.indexOf("#") == 0)
                                value = "0x" + value.substring(1);
                            else if (value.indexOf("%") != -1)
                                value = (parseFloat(value.substr(0, value.length - 1))).toString();
                            break;
                        case "boolean":
                            value = (value == "false" || !value) ? "false" : "true";
                            break;
                        case "string":
                        case "any":
                            value = this.formatString(stringValue);
                            break;
                        default:
                            if (DEBUG) {
                                lark.$error(2008, this.currentClassName, "string", key + ":" + type, toXMLString(node));
                            }
                            break;
                    }
                }
                return value;
            };
            /**
             * 格式化字符串
             */
            p.formatString = function (value) {
                value = this.unescapeHTMLEntity(value);
                value = value.split("\n").join("\\n");
                value = value.split("\r").join("\\n");
                value = value.split("\"").join("\\\"");
                value = "\"" + value + "\"";
                return value;
            };
            /**
             /**
             * 转换HTML实体字符为普通字符
             */
            p.unescapeHTMLEntity = function (str) {
                if (!str)
                    return "";
                var length = htmlEntities.length;
                for (var i = 0; i < length; i++) {
                    var arr = htmlEntities[i];
                    var key = arr[0];
                    var value = arr[1];
                    str = str.split(value).join(key);
                }
                return str;
            };
            /**
             * 创建构造函数
             */
            p.createConstructFunc = function () {
                var cb = new player.CpCodeBlock;
                cb.addEmptyLine();
                var varName = "this";
                this.addAttributesToCodeBlock(cb, varName, this.currentXML);
                if (this.declarations) {
                    var children = this.declarations.children;
                    if (children && children.length > 0) {
                        var length = children.length;
                        for (var i = 0; i < length; i++) {
                            var decl = children[i];
                            if (decl.nodeType != 1) {
                                continue;
                            }
                            var funcName = this.createFuncForNode(decl);
                            if (funcName) {
                                cb.addCodeLine(funcName + ";");
                            }
                        }
                    }
                }
                this.initlizeChildNode(this.currentXML, cb, varName);
                var id;
                var stateIds = this.stateIds;
                if (stateIds.length > 0) {
                    length = stateIds.length;
                    for (var i = 0; i < length; i++) {
                        id = stateIds[i];
                        cb.addCodeLine("this." + id + "_i();");
                    }
                    cb.addEmptyLine();
                }
                var skinParts = this.skinParts;
                var skinPartStr = "[]";
                length = skinParts.length;
                if (length > 0) {
                    for (i = 0; i < length; i++) {
                        skinParts[i] = "\"" + skinParts[i] + "\"";
                    }
                    skinPartStr = "[" + skinParts.join(",") + "]";
                }
                var skinPartFunc = new player.CpFunction();
                skinPartFunc.name = "skinParts";
                skinPartFunc.isGet = true;
                var skinPartCB = new player.CpCodeBlock();
                skinPartCB.addReturn(skinPartStr);
                skinPartFunc.codeBlock = skinPartCB;
                this.currentClass.addFunction(skinPartFunc);
                this.currentXML.attributes.id = "";
                //生成视图状态代码
                this.createStates(this.currentXML);
                var states;
                var node = this.currentXML;
                var nodeClassName = this.getClassNameOfNode(node);
                var attributes = node.attributes;
                var keys = Object.keys(attributes);
                var keysLength = keys.length;
                for (var m = 0; m < keysLength; m++) {
                    var itemName = keys[m];
                    var value = attributes[itemName];
                    var index = itemName.indexOf(".");
                    if (index != -1) {
                        var key = itemName.substring(0, index);
                        key = this.formatKey(key, value);
                        var itemValue = this.formatValue(key, value, node);
                        if (!itemValue) {
                            continue;
                        }
                        var stateName = itemName.substr(index + 1);
                        states = this.getStateByName(stateName, node);
                        var stateLength = states.length;
                        if (stateLength > 0) {
                            for (var i = 0; i < stateLength; i++) {
                                var state = states[i];
                                state.addOverride(new player.CpSetProperty("", key, itemValue));
                            }
                        }
                    }
                }
                //打印视图状态初始化代码
                var stateCode = this.stateCode;
                if (stateCode.length > 0) {
                    cb.addCodeLine("this.states = [");
                    var first = true;
                    var indentStr = "	";
                    var length = stateCode.length;
                    for (var i = 0; i < length; i++) {
                        state = stateCode[i];
                        if (first)
                            first = false;
                        else
                            cb.addCodeLine(indentStr + ",");
                        var codes = state.toCode().split("\n");
                        var codeIndex = 0;
                        while (codeIndex < codes.length) {
                            var code = codes[codeIndex];
                            if (code)
                                cb.addCodeLine(indentStr + code);
                            codeIndex++;
                        }
                    }
                    cb.addCodeLine("];");
                }
                this.currentClass.constructCode = cb;
            };
            /**
             * 是否含有includeIn和excludeFrom属性
             */
            p.isStateNode = function (node) {
                var attributes = node.attributes;
                return attributes.hasOwnProperty("includeIn") || attributes.hasOwnProperty("excludeFrom");
            };
            /**
             * 获取视图状态名称列表
             */
            p.getStateNames = function () {
                var stateNames = this.stateNames;
                var states;
                var children = this.currentXML.children;
                if (children) {
                    var length = children.length;
                    for (var i = 0; i < length; i++) {
                        var item = children[i];
                        if (item.nodeType == 1 && item.localName == "states") {
                            item.namespace = player.NS_W;
                            states = item.children;
                            break;
                        }
                    }
                }
                if (!states)
                    return;
                if (states.length == 0) {
                    if (DEBUG) {
                        lark.$warn(2102, this.currentClassName, getPropertyStr(item));
                    }
                    return;
                }
                length = states.length;
                for (i = 0; i < length; i++) {
                    var state = states[i];
                    if (state.nodeType != 1) {
                        continue;
                    }
                    var stateGroups = [];
                    var attributes = state.attributes;
                    if (attributes["stateGroups"]) {
                        var groups = attributes.stateGroups.split(",");
                        var len = groups.length;
                        for (var j = 0; j < len; j++) {
                            var group = groups[j].trim();
                            if (group) {
                                if (stateNames.indexOf(group) == -1) {
                                    stateNames.push(group);
                                }
                                stateGroups.push(group);
                            }
                        }
                    }
                    var stateName = attributes.name;
                    if (stateNames.indexOf(stateName) == -1) {
                        stateNames.push(stateName);
                    }
                    this.stateCode.push(new player.CpState(stateName, stateGroups));
                }
            };
            /**
             * 解析视图状态代码
             */
            p.createStates = function (parentNode) {
                var items = parentNode.children;
                if (!items) {
                    return;
                }
                var className = this.getClassNameOfNode(parentNode);
                var length = items.length;
                for (var i = 0; i < length; i++) {
                    var node = items[i];
                    if (node.nodeType != 1 || (node.localName == "Skin" && node.namespace == player.NS_E)) {
                        continue;
                    }
                    this.createStates(node);
                    if (node.namespace == player.NS_W || !node.localName) {
                        continue;
                    }
                    if (this.isProperty(node, className)) {
                        var prop = node.localName;
                        var index = prop.indexOf(".");
                        var children = node.children;
                        if (index == -1 || !children || children.length == 0) {
                            continue;
                        }
                        var stateName = prop.substring(index + 1);
                        prop = prop.substring(0, index);
                        var type = player.exmlConfig.getPropertyType(prop, className);
                        if (DEBUG) {
                            if (type == "Array") {
                                lark.$error(2013, this.currentClassName, getPropertyStr(node));
                            }
                            if (children.length > 1) {
                                lark.$error(2011, this.currentClassName, prop, getPropertyStr(node));
                            }
                        }
                        var firstChild = children[0];
                        var value;
                        if (firstChild.nodeType == 1) {
                            this.createFuncForNode(firstChild);
                            this.checkIdForState(firstChild);
                            value = "this." + firstChild.attributes.id;
                        }
                        else {
                            value = this.formatValue(prop, firstChild.text, parentNode);
                        }
                        states = this.getStateByName(stateName, node);
                        var l = states.length;
                        if (l > 0) {
                            for (var j = 0; j < l; j++) {
                                state = states[j];
                                state.addOverride(new player.CpSetProperty(parentNode.attributes.id, prop, value));
                            }
                        }
                    }
                    else if (this.containsState(node)) {
                        var attributes = node.attributes;
                        var id = attributes.id;
                        var nodeClassName = this.getClassNameOfNode(node);
                        this.checkIdForState(node);
                        var stateName;
                        var states;
                        var state;
                        if (this.isStateNode(node)) {
                            var propertyName = "";
                            var parent = node.parent;
                            if (parent.localName == "Array")
                                parent = parent.parent;
                            if (parent && parent.parent) {
                                var parentClassName = this.getClassNameOfNode(parent.parent);
                                if (this.isProperty(parent, parentClassName))
                                    parent = parent.parent;
                            }
                            if (parent && parent != this.currentXML) {
                                propertyName = parent.attributes.id;
                                this.checkIdForState(parent);
                            }
                            var positionObj = this.findNearNodeId(node);
                            var stateNames = [];
                            if (attributes.includeIn) {
                                stateNames = attributes.includeIn.split(",");
                            }
                            else {
                                var excludeNames = attributes.excludeFrom.split(",");
                                var stateLength = excludeNames.length;
                                for (var j = 0; j < stateLength; j++) {
                                    var name = excludeNames[j];
                                    this.getStateByName(name, node); //检查exlcudeFrom是否含有未定义的视图状态名
                                }
                                stateLength = this.stateCode.length;
                                for (j = 0; j < stateLength; j++) {
                                    state = this.stateCode[j];
                                    if (excludeNames.indexOf(state.name) == -1) {
                                        stateNames.push(state.name);
                                    }
                                }
                            }
                            var len = stateNames.length;
                            for (var k = 0; k < len; k++) {
                                stateName = stateNames[k];
                                states = this.getStateByName(stateName, node);
                                if (states.length > 0) {
                                    var l = states.length;
                                    for (var j = 0; j < l; j++) {
                                        state = states[j];
                                        state.addOverride(new player.CpAddItems(id, propertyName, positionObj.position, positionObj.relativeTo));
                                    }
                                }
                            }
                        }
                        var names = Object.keys(attributes);
                        var namesLength = names.length;
                        for (var m = 0; m < namesLength; m++) {
                            name = names[m];
                            var value = attributes[name];
                            var index = name.indexOf(".");
                            if (index != -1) {
                                var key = name.substring(0, index);
                                key = this.formatKey(key, value);
                                var value = this.formatValue(key, value, node);
                                if (!value) {
                                    continue;
                                }
                                stateName = name.substr(index + 1);
                                states = this.getStateByName(stateName, node);
                                var l = states.length;
                                if (l > 0) {
                                    for (var j = 0; j < l; j++) {
                                        state = states[j];
                                        state.addOverride(new player.CpSetProperty(id, key, value));
                                    }
                                }
                            }
                        }
                    }
                }
            };
            /**
             * 检查指定的ID是否创建了类成员变量，若没创建则为其创建。
             */
            p.checkIdForState = function (node) {
                if (!node || this.currentClass.getVariableByName(node.attributes.id)) {
                    return;
                }
                this.createVarForNode(node);
                var id = node.attributes.id;
                var funcName = id + "_i";
                var func = this.currentClass.getFuncByName(funcName);
                if (!func)
                    return;
                var codeLine = "this." + id + " = t;";
                var cb = func.codeBlock;
                if (!cb)
                    return;
                if (!cb.containsCodeLine(codeLine)) {
                    cb.addCodeLineAt(codeLine, 1);
                }
            };
            /**
             * 通过视图状态名称获取对应的视图状态
             */
            p.getStateByName = function (name, node) {
                var states = [];
                var stateCode = this.stateCode;
                var length = stateCode.length;
                for (var i = 0; i < length; i++) {
                    var state = stateCode[i];
                    if (state.name == name) {
                        if (states.indexOf(state) == -1)
                            states.push(state);
                    }
                    else if (state.stateGroups.length > 0) {
                        var found = false;
                        var len = state.stateGroups.length;
                        for (var j = 0; j < len; j++) {
                            var g = state.stateGroups[j];
                            if (g == name) {
                                found = true;
                                break;
                            }
                        }
                        if (found) {
                            if (states.indexOf(state) == -1)
                                states.push(state);
                        }
                    }
                }
                if (DEBUG && states.length == 0) {
                    lark.$error(2006, this.currentClassName, name, toXMLString(node));
                }
                return states;
            };
            /**
             * 寻找节点的临近节点ID和位置
             */
            p.findNearNodeId = function (node) {
                var parentNode = node.parent;
                var targetId = "";
                var position;
                var index = -1;
                var preItem;
                var afterItem;
                var found = false;
                var className = this.getClassNameOfNode(node);
                var children = parentNode.children;
                var length = children.length;
                for (var i = 0; i < length; i++) {
                    var item = children[i];
                    if (this.isProperty(item, className))
                        continue;
                    if (item == node) {
                        found = true;
                        index = i;
                    }
                    else {
                        if (found && !afterItem && !this.isStateNode(item)) {
                            afterItem = item;
                        }
                    }
                    if (!found && !this.isStateNode(item))
                        preItem = item;
                }
                if (index == 0) {
                    position = "first";
                    return { position: position, relativeTo: targetId };
                }
                if (index == length - 1) {
                    position = "last";
                    return { position: position, relativeTo: targetId };
                }
                if (afterItem) {
                    position = "before";
                    targetId = afterItem.attributes.id;
                    if (targetId) {
                        this.checkIdForState(afterItem);
                        return { position: position, relativeTo: targetId };
                    }
                }
                return { position: "last", relativeTo: targetId };
            };
            /**
             * 获取节点的完整类名，包括模块名
             */
            p.getClassNameOfNode = function (node) {
                if (node.namespace == player.NS_W) {
                    return "";
                }
                var className = player.exmlConfig.getClassNameById(node.localName, node.namespace);
                if (DEBUG && !className) {
                    lark.$error(2003, this.currentClassName, toXMLString(node));
                }
                return className;
            };
            return EXMLParser;
        })();
        player.EXMLParser = EXMLParser;
        EXMLParser.prototype.__class__ = "lark.player.EXMLParser";
        if (DEBUG) {
            /**
             * 获取重复的ID名
             */
            function getRepeatedIds(xml) {
                var result = [];
                this.getIds(xml, result);
                this.repeatedIdMap = {};
                return result;
            }
            function getIds(xml, result) {
                if (xml.namespace != player.NS_W && xml["$id"]) {
                    var id = xml.$id;
                    if (this.repeatedIdMap[id]) {
                        result.push(toXMLString(xml));
                    }
                    else {
                        this.repeatedIdMap[id] = true;
                    }
                }
                var children = xml.children;
                if (children) {
                    var length = children.length;
                    for (var i = 0; i < length; i++) {
                        var node = children[i];
                        getIds(node, result);
                    }
                }
            }
            function toXMLString(node) {
                if (!node) {
                    return "";
                }
                var str = "  at <" + node.name;
                var attributes = node.attributes;
                var keys = Object.keys(attributes);
                var length = keys.length;
                for (var i = 0; i < length; i++) {
                    var key = keys[i];
                    var value = attributes[key];
                    if (key == "id" && value.substring(0, 2) == "__") {
                        continue;
                    }
                    str += " " + key + "=\"" + value + "\"";
                }
                if (node.children.length == 0) {
                    str += "/>";
                }
                else {
                    str += ">";
                }
                return str;
            }
            /**
             * 清理声明节点里的状态标志
             */
            function checkDeclarations(declarations, list) {
                if (!declarations) {
                    return;
                }
                var children = declarations.children;
                if (children) {
                    var length = children.length;
                    for (var i = 0; i < length; i++) {
                        var node = children[i];
                        if (node.nodeType != 1) {
                            continue;
                        }
                        if (node.attributes.includeIn) {
                            list.push(toXMLString(node));
                        }
                        if (node.attributes.excludeFrom) {
                            list.push(toXMLString(node));
                        }
                        checkDeclarations(node, list);
                    }
                }
            }
            function getPropertyStr(child) {
                var parentStr = toXMLString(child.parent);
                var childStr = toXMLString(child).substring(5);
                return parentStr + "\n      \t" + childStr;
            }
        }
    })(player = lark.player || (lark.player = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        var groupCount = 0;
        /**
         * 显示列表深度排序
         */
        function breadthOrderCompare(a, b) {
            var aParent = a.parent;
            var bParent = b.parent;
            if (!aParent || !bParent)
                return 0;
            var aNestLevel = a.$nestLevel;
            var bNestLevel = b.$nestLevel;
            var aIndex = 0;
            var bIndex = 0;
            if (aParent == bParent) {
                aIndex = aParent.getChildIndex(a);
                bIndex = bParent.getChildIndex(b);
            }
            if (aNestLevel > bNestLevel || aIndex > bIndex)
                return 1;
            if (aNestLevel < bNestLevel || bIndex > aIndex)
                return -1;
            if (a == b)
                return 0;
            return breadthOrderCompare(aParent, bParent);
        }
        /**
         * RadioButtonGroup 组件定义一组 RadioButton 组件，这些组件相互排斥；因此，用户每次只能选择一个 RadioButton 组件
         */
        var RadioButtonGroup = (function (_super) {
            __extends(RadioButtonGroup, _super);
            /**
             * 创建一个RadioButtonGroup实例
             */
            function RadioButtonGroup() {
                _super.call(this);
                /**
                 * 组名
                 */
                this.$name = null;
                /**
                 * 单选按钮列表
                 */
                this.radioButtons = [];
                this.$enabled = true;
                this._selectedValue = null;
                this._selection = null;
                this.$name = "_radioButtonGroup" + groupCount++;
            }var d = __define,c=RadioButtonGroup;p=c.prototype;
            /**
             * 获取指定索引的单选按钮
             * @param index 单选按钮的索引
             */
            p.getRadioButtonAt = function (index) {
                return this.radioButtons[index];
            };
            d(p, "enabled", {
                /**
                 * 组件是否可以接受用户交互。默认值为true。设置此属性将影响组内所有单选按钮。
                 */
                g: function () {
                    return this.$enabled;
                },
                s: function (value) {
                    value = !!value;
                    if (this.$enabled === value)
                        return;
                    this.$enabled = value;
                    var buttons = this.radioButtons;
                    var length = buttons.length;
                    for (var i = 0; i < length; i++)
                        buttons[i].invalidateSkinState();
                },
            });
            d(p, "numRadioButtons", {
                /**
                 * 组内单选按钮数量
                 */
                g: function () {
                    return this.radioButtons.length;
                },
            });
            d(p, "selectedValue", {
                /**
                 * 当前被选中的单选按钮的value属性值。注意，此属性仅当目标RadioButton在显示列表时有效。
                 */
                g: function () {
                    if (this.selection) {
                        return this.selection.value != null ? this.selection.value : this.selection.label;
                    }
                    return null;
                },
                s: function (value) {
                    this._selectedValue = value;
                    if (value == null) {
                        this.$setSelection(null, false);
                        return;
                    }
                    var n = this.numRadioButtons;
                    for (var i = 0; i < n; i++) {
                        var radioButton = this.radioButtons[i];
                        if (radioButton.value == value || radioButton.label == value) {
                            this.changeSelection(i, false);
                            this._selectedValue = null;
                            gui.UIEvent.emitUIEvent(this, gui.UIEvent.VALUE_COMMIT);
                            break;
                        }
                    }
                },
            });
            d(p, "selection", {
                /**
                 * 当前被选中的单选按钮引用,注意，此属性仅当目标RadioButton在显示列表时有效。
                 */
                g: function () {
                    return this._selection;
                },
                s: function (value) {
                    if (this._selection == value)
                        return;
                    this.$setSelection(value, false);
                },
            });
            /**
             * 添加单选按钮到组内
             */
            p.$addInstance = function (instance) {
                instance.on(lark.Event.REMOVED, this.removedHandler, this);
                var buttons = this.radioButtons;
                buttons.push(instance);
                buttons.sort(breadthOrderCompare);
                var length = buttons.length;
                for (var i = 0; i < length; i++) {
                    buttons[i].$indexNumber = i;
                }
                if (this._selectedValue)
                    this.selectedValue = this._selectedValue;
                if (instance.selected == true)
                    this.selection = instance;
                instance.$radioButtonGroup = this;
                instance.invalidateSkinState();
            };
            /**
             * 从组里移除单选按钮
             */
            p.$removeInstance = function (instance, addListener) {
                if (instance) {
                    var foundInstance = false;
                    var buttons = this.radioButtons;
                    var length = buttons.length;
                    for (var i = 0; i < length; i++) {
                        var rb = buttons[i];
                        if (foundInstance) {
                            rb.$indexNumber = rb.$indexNumber - 1;
                        }
                        else if (rb == instance) {
                            if (addListener)
                                instance.on(lark.Event.ADDED, this.addedHandler, this);
                            if (instance == this._selection)
                                this._selection = null;
                            instance.$radioButtonGroup = null;
                            instance.invalidateSkinState();
                            this.radioButtons.splice(i, 1);
                            foundInstance = true;
                            i--;
                        }
                    }
                }
            };
            /**
             * 设置选中的单选按钮
             */
            p.$setSelection = function (value, fireChange) {
                if (this._selection == value)
                    return;
                if (!value) {
                    if (this._selection) {
                        this._selection.selected = false;
                        this._selection = null;
                        if (fireChange)
                            this.emitWith(lark.Event.CHANGE);
                    }
                }
                else {
                    var n = this.numRadioButtons;
                    for (var i = 0; i < n; i++) {
                        if (value == this.getRadioButtonAt(i)) {
                            this.changeSelection(i, fireChange);
                            break;
                        }
                    }
                }
                gui.UIEvent.emitUIEvent(this, gui.UIEvent.VALUE_COMMIT);
            };
            /**
             * 改变选中项
             */
            p.changeSelection = function (index, fireChange) {
                var rb = this.getRadioButtonAt(index);
                if (rb && rb != this._selection) {
                    if (this._selection)
                        this._selection.selected = false;
                    this._selection = rb;
                    this._selection.selected = true;
                    if (fireChange)
                        this.emitWith(lark.Event.CHANGE);
                }
            };
            /**
             * 单选按钮添加到显示列表
             */
            p.addedHandler = function (event) {
                var rb = event.target;
                if (rb) {
                    rb.removeListener(lark.Event.ADDED, this.addedHandler, this);
                    this.$addInstance(rb);
                }
            };
            /**
             * 单选按钮从显示列表移除
             */
            p.removedHandler = function (event) {
                var rb = event.target;
                if (rb) {
                    rb.removeListener(lark.Event.REMOVED, this.removedHandler, this);
                    this.$removeInstance(rb, true);
                }
            };
            return RadioButtonGroup;
        })(lark.EventEmitter);
        gui.RadioButtonGroup = RadioButtonGroup;
        RadioButtonGroup.prototype.__class__ = "lark.gui.RadioButtonGroup";
        lark.registerClass(RadioButtonGroup, 1017 /* RadioButtonGroup */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var player;
    (function (player) {
        function isDeltaIdentity(m) {
            return (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1);
        }
        /**
         * GUI显示对象基类模板。仅作为gui.UIComponent的默认实现，为lark.player.implemenetUIComponenet()方法提供代码模板。
         * 注意：在此类里不允许直接使用super关键字访问父类方法。一律使用this.$super属性访问。
         */
        var UIComponentImpl = (function (_super) {
            __extends(UIComponentImpl, _super);
            /**
             * 构造函数
             */
            function UIComponentImpl() {
                _super.call(this);
                this.$includeInLayout = true;
                this.$uiValues = new Float64Array([
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    lark.NONE,
                    0,
                    0,
                    0,
                    100000,
                    0,
                    100000,
                    0,
                    0,
                    lark.NONE,
                    lark.NONE,
                    0,
                    0,
                    0,
                    0
                ]);
                this.$displayObjectFlags |= 9306112 /* UIComponentInitFlags */;
                this.createChildren();
            }var d = __define,c=UIComponentImpl;p=c.prototype;
            /**
             * 创建子项,子类覆盖此方法以完成组件子项的初始化操作，
             * 请务必调用super.createChildren()以完成父类组件的初始化
             */
            p.createChildren = function () {
            };
            /**
             * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
             */
            p.commitProperties = function () {
            };
            /**
             * 测量组件尺寸
             */
            p.measure = function () {
            };
            /**
             * 更新显示列表
             */
            p.updateDisplayList = function (unscaledWidth, unscaledHeight) {
            };
            d(p, "includeInLayout", {
                /**
                 * 指定此组件是否包含在父容器的布局中。若为false，则父级容器在测量和布局阶段都忽略此组件。默认值为true。
                 * 注意，visible属性与此属性不同，设置visible为false，父级容器仍会对其布局。
                 */
                g: function () {
                    return this.$includeInLayout;
                },
                s: function (value) {
                    value = !!value;
                    if (this.$includeInLayout === value)
                        return;
                    this.$includeInLayout = true;
                    this.invalidateParentLayout();
                    this.$includeInLayout = value;
                },
            });
            p.$onAddToStage = function (stage, nestLevel) {
                this.$super.$onAddToStage.call(this, stage, nestLevel);
                this.checkInvalidateFlag();
            };
            /**
             * 检查属性失效标记并应用
             */
            p.checkInvalidateFlag = function (event) {
                var validator = lark.gui.validator;
                if (this.$hasFlags(131072 /* InvalidatePropertiesFlag */)) {
                    validator.invalidateProperties(this);
                }
                if (this.$hasFlags(262144 /* InvalidateSizeFlag */)) {
                    validator.invalidateSize(this);
                }
                if (this.$hasFlags(524288 /* InvalidateDisplayListFlag */)) {
                    validator.invalidateDisplayList(this);
                }
            };
            d(p, "left", {
                /**
                 * 距父级容器离左边距离
                 */
                g: function () {
                    return this.$uiValues[0 /* left */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[0 /* left */] === value)
                        return;
                    values[0 /* left */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "right", {
                /**
                 * 距父级容器右边距离
                 */
                g: function () {
                    return this.$uiValues[1 /* right */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[1 /* right */] === value)
                        return;
                    values[1 /* right */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "top", {
                /**
                 * 距父级容器顶部距离
                 */
                g: function () {
                    return this.$uiValues[2 /* top */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[2 /* top */] === value)
                        return;
                    values[2 /* top */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "bottom", {
                /**
                 * 距父级容器底部距离
                 */
                g: function () {
                    return this.$uiValues[3 /* bottom */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[3 /* bottom */] == value)
                        return;
                    values[3 /* bottom */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "horizontalCenter", {
                /**
                 * 在父级容器中距水平中心位置的距离
                 */
                g: function () {
                    return this.$uiValues[4 /* horizontalCenter */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[4 /* horizontalCenter */] === value)
                        return;
                    values[4 /* horizontalCenter */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "verticalCenter", {
                /**
                 * 在父级容器中距竖直中心位置的距离
                 */
                g: function () {
                    return this.$uiValues[5 /* verticalCenter */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[5 /* verticalCenter */] === value)
                        return;
                    values[5 /* verticalCenter */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "percentWidth", {
                /**
                 * 相对父级容器宽度的百分比
                 */
                g: function () {
                    return this.$uiValues[6 /* percentWidth */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[6 /* percentWidth */] === value)
                        return;
                    values[6 /* percentWidth */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "percentHeight", {
                /**
                 * 相对父级容器高度的百分比
                 */
                g: function () {
                    return this.$uiValues[7 /* percentHeight */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (values[7 /* percentHeight */] === value)
                        return;
                    values[7 /* percentHeight */] = value;
                    this.invalidateParentLayout();
                },
            });
            d(p, "explicitWidth", {
                /**
                 * 外部显式指定的宽度
                 */
                g: function () {
                    return this.$uiValues[8 /* explicitWidth */];
                },
            });
            d(p, "explicitHeight", {
                /**
                 * 外部显式指定的高度
                 */
                g: function () {
                    return this.$uiValues[9 /* explicitHeight */];
                },
            });
            /**
             * 组件宽度,默认值为lark.NONE,设置为lark.NONE将使用组件的measure()方法自动计算尺寸
             */
            p.$getWidth = function () {
                this.validateSizeNow();
                return this.$uiValues[10 /* width */];
            };
            p.$setWidth = function (value) {
                value = +value || 0;
                var values = this.$uiValues;
                if (value < 0 || values[10 /* width */] === value && values[8 /* explicitWidth */] === value)
                    return;
                values[10 /* width */] = value;
                values[8 /* explicitWidth */] = value;
                if (isNaN(value))
                    this.invalidateSize();
                this.invalidateDisplayList();
                this.invalidateParentLayout();
            };
            /**
             * 立即验证自身的尺寸。
             */
            p.validateSizeNow = function () {
                this.validateSize(true);
                this.updateFinalSize();
            };
            /**
             * 组件高度,默认值为NaN,设置为NaN将使用组件的measure()方法自动计算尺寸
             */
            p.$getHeight = function () {
                this.validateSizeNow();
                return this.$uiValues[11 /* height */];
            };
            p.$setHeight = function (value) {
                value = +value || 0;
                var values = this.$uiValues;
                if (value < 0 || values[11 /* height */] === value && values[9 /* explicitHeight */] === value)
                    return;
                values[11 /* height */] = value;
                values[9 /* explicitHeight */] = value;
                if (isNaN(value))
                    this.invalidateSize();
                this.invalidateDisplayList();
                this.invalidateParentLayout();
            };
            p.$setScaleX = function (value) {
                var change = this.$super.$setScaleX.call(this, value);
                if (change) {
                    this.invalidateParentLayout();
                }
                return change;
            };
            p.$setScaleY = function (value) {
                var change = this.$super.$setScaleY.call(this, value);
                if (change) {
                    this.invalidateParentLayout();
                }
                return change;
            };
            d(p, "minWidth", {
                /**
                 * 组件的最小宽度,此属性设置为大于maxWidth的值时无效。同时影响测量和自动布局的尺寸。
                 */
                g: function () {
                    return this.$uiValues[12 /* minWidth */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (value < 0 || values[12 /* minWidth */] === value) {
                        return;
                    }
                    values[12 /* minWidth */] = value;
                    this.invalidateSize();
                    this.invalidateParentLayout();
                },
            });
            d(p, "maxWidth", {
                /**
                 * 组件的最大高度。同时影响测量和自动布局的尺寸。
                 */
                g: function () {
                    return this.$uiValues[13 /* maxWidth */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (value < 0 || values[13 /* maxWidth */] === value) {
                        return;
                    }
                    values[13 /* maxWidth */] = value;
                    this.invalidateSize();
                    this.invalidateParentLayout();
                },
            });
            d(p, "minHeight", {
                /**
                 * 组件的最小高度,此属性设置为大于maxHeight的值时无效。同时影响测量和自动布局的尺寸。
                 */
                g: function () {
                    return this.$uiValues[14 /* minHeight */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (value < 0 || values[14 /* minHeight */] === value) {
                        return;
                    }
                    values[14 /* minHeight */] = value;
                    this.invalidateSize();
                    this.invalidateParentLayout();
                },
            });
            d(p, "maxHeight", {
                /**
                 * 组件的最大高度,同时影响测量和自动布局的尺寸。
                 */
                g: function () {
                    return this.$uiValues[15 /* maxHeight */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (value < 0 || values[15 /* maxHeight */] === value) {
                        return;
                    }
                    values[15 /* maxHeight */] = value;
                    this.invalidateSize();
                    this.invalidateParentLayout();
                },
            });
            /**
             * 设置测量结果。
             * @param width 测量宽度
             * @param height 测量高度
             */
            p.setMeasuredSize = function (width, height) {
                var values = this.$uiValues;
                values[16 /* measuredWidth */] = Math.ceil(+width || 0);
                values[17 /* measuredHeight */] = Math.ceil(+height || 0);
            };
            /**
             * 设置组件的宽高。此方法不同于直接设置width,height属性，
             * 不会影响显式标记尺寸属性
             */
            p.setActualSize = function (w, h) {
                var change = false;
                var values = this.$uiValues;
                if (values[10 /* width */] !== w) {
                    values[10 /* width */] = w;
                    change = true;
                }
                if (values[11 /* height */] !== h) {
                    values[11 /* height */] = h;
                    change = true;
                }
                if (change) {
                    this.invalidateDisplayList();
                }
            };
            p.$setX = function (value) {
                var change = this.$super.$setX.call(this, value);
                if (change) {
                    this.invalidateParentLayout();
                }
                return change;
            };
            p.$setY = function (value) {
                var change = this.$super.$setY.call(this, value);
                if (change) {
                    this.invalidateParentLayout();
                }
                return change;
            };
            /**
             * 标记属性失效
             */
            p.invalidateProperties = function () {
                if (!this.$hasFlags(131072 /* InvalidatePropertiesFlag */)) {
                    this.$setFlags(131072 /* InvalidatePropertiesFlag */);
                    if (this.$stage)
                        lark.gui.validator.invalidateProperties(this);
                }
            };
            /**
             * 验证组件的属性
             */
            p.validateProperties = function () {
                if (this.$hasFlags(131072 /* InvalidatePropertiesFlag */)) {
                    this.commitProperties();
                    this.$removeFlags(131072 /* InvalidatePropertiesFlag */);
                }
            };
            /**
             * 标记提交过需要验证组件尺寸
             */
            p.invalidateSize = function () {
                if (!this.$hasFlags(262144 /* InvalidateSizeFlag */)) {
                    this.$setFlags(262144 /* InvalidateSizeFlag */);
                    if (this.$stage)
                        lark.gui.validator.invalidateSize(this);
                }
            };
            /**
             * 验证组件的尺寸
             */
            p.validateSize = function (recursive) {
                if (recursive) {
                    var children = this.$children;
                    if (children) {
                        var length = children.length;
                        for (var i = 0; i < length; i++) {
                            var child = children[i];
                            if (lark.is(child, 1001 /* UIComponent */)) {
                                child.validateSize(true);
                            }
                        }
                    }
                }
                if (this.$hasFlags(262144 /* InvalidateSizeFlag */)) {
                    var changed = this.measureSizes();
                    if (changed) {
                        this.invalidateDisplayList();
                        this.invalidateParentLayout();
                    }
                    this.$removeFlags(262144 /* InvalidateSizeFlag */);
                }
            };
            /**
             * 测量组件尺寸，返回尺寸是否发生变化
             */
            p.measureSizes = function () {
                var changed = false;
                if (!this.$hasFlags(262144 /* InvalidateSizeFlag */))
                    return changed;
                var values = this.$uiValues;
                if (lark.isNone(values[8 /* explicitWidth */]) || lark.isNone(values[9 /* explicitHeight */])) {
                    this.measure();
                    if (values[16 /* measuredWidth */] < values[12 /* minWidth */]) {
                        values[16 /* measuredWidth */] = values[12 /* minWidth */];
                    }
                    if (values[16 /* measuredWidth */] > values[13 /* maxWidth */]) {
                        values[16 /* measuredWidth */] = values[13 /* maxWidth */];
                    }
                    if (values[17 /* measuredHeight */] < values[14 /* minHeight */]) {
                        values[17 /* measuredHeight */] = values[14 /* minHeight */];
                    }
                    if (values[17 /* measuredHeight */] > values[15 /* maxHeight */]) {
                        values[17 /* measuredHeight */] = values[15 /* maxHeight */];
                    }
                }
                var preferredW = this.getPreferredUWidth();
                var preferredH = this.getPreferredUHeight();
                if (preferredW !== values[18 /* oldPreferWidth */] || preferredH !== values[19 /* oldPreferHeight */]) {
                    values[18 /* oldPreferWidth */] = preferredW;
                    values[19 /* oldPreferHeight */] = preferredH;
                    changed = true;
                }
                return changed;
            };
            /**
             * 标记需要验证显示列表
             */
            p.invalidateDisplayList = function () {
                if (!this.$hasFlags(524288 /* InvalidateDisplayListFlag */)) {
                    this.$setFlags(524288 /* InvalidateDisplayListFlag */);
                    if (this.$stage)
                        lark.gui.validator.invalidateDisplayList(this);
                }
            };
            /**
             * 验证子项的位置和大小，并绘制其他可视内容
             */
            p.validateDisplayList = function () {
                if (this.$hasFlags(524288 /* InvalidateDisplayListFlag */)) {
                    this.updateFinalSize();
                    var values = this.$uiValues;
                    this.updateDisplayList(values[10 /* width */], values[11 /* height */]);
                    this.$removeFlags(524288 /* InvalidateDisplayListFlag */);
                }
            };
            /**
             * 更新最终的组件宽高
             */
            p.updateFinalSize = function () {
                var unscaledWidth = 0;
                var unscaledHeight = 0;
                var values = this.$uiValues;
                if (this.$hasFlags(1048576 /* LayoutWidthExplicitlySet */)) {
                    unscaledWidth = values[10 /* width */];
                }
                else if (!lark.isNone(values[8 /* explicitWidth */])) {
                    unscaledWidth = values[8 /* explicitWidth */];
                }
                else {
                    unscaledWidth = values[16 /* measuredWidth */];
                }
                if (this.$hasFlags(2097152 /* LayoutHeightExplicitlySet */)) {
                    unscaledHeight = values[11 /* height */];
                }
                else if (!lark.isNone(values[9 /* explicitHeight */])) {
                    unscaledHeight = values[9 /* explicitHeight */];
                }
                else {
                    unscaledHeight = values[17 /* measuredHeight */];
                }
                this.setActualSize(unscaledWidth, unscaledHeight);
            };
            /**
             * 立即应用组件及其子项的所有属性
             */
            p.validateNow = function () {
                if (this.$stage)
                    lark.gui.validator.validateClient(this);
            };
            /**
             * 标记父级容器的尺寸和显示列表为失效
             */
            p.invalidateParentLayout = function () {
                var parent = this.$parent;
                if (!parent || !this.$includeInLayout || !lark.is(parent, 1001 /* UIComponent */))
                    return;
                parent.invalidateSize();
                parent.invalidateDisplayList();
            };
            /**
             * 设置组件的布局宽高
             */
            p.setLayoutBoundsSize = function (layoutWidth, layoutHeight) {
                layoutHeight = +layoutHeight || 0;
                layoutWidth = +layoutWidth || 0;
                var values = this.$uiValues;
                var maxWidth = values[13 /* maxWidth */];
                var maxHeight = values[15 /* maxHeight */];
                var minWidth = Math.min(values[12 /* minWidth */], maxWidth);
                var minHeight = Math.min(values[14 /* minHeight */], maxHeight);
                var width;
                var height;
                if (lark.isNone(layoutWidth)) {
                    this.$removeFlags(1048576 /* LayoutWidthExplicitlySet */);
                    width = this.getPreferredUWidth();
                }
                else {
                    this.$setFlags(1048576 /* LayoutWidthExplicitlySet */);
                    width = Math.max(minWidth, Math.min(maxWidth, layoutWidth));
                }
                if (lark.isNone(layoutHeight)) {
                    this.$removeFlags(2097152 /* LayoutHeightExplicitlySet */);
                    height = this.getPreferredUHeight();
                }
                else {
                    this.$setFlags(2097152 /* LayoutHeightExplicitlySet */);
                    height = Math.max(minHeight, Math.min(maxHeight, layoutHeight));
                }
                var matrix = this.$getMatrix();
                if (isDeltaIdentity(matrix.$data)) {
                    this.setActualSize(width, height);
                    return;
                }
                var fitSize = player.MatrixUtil.fitBounds(layoutWidth, layoutHeight, matrix, values[8 /* explicitWidth */], values[9 /* explicitHeight */], this.getPreferredUWidth(), this.getPreferredUHeight(), minWidth, minHeight, maxWidth, maxHeight);
                if (!fitSize) {
                    fitSize = lark.Point.create(minWidth, minHeight);
                }
                this.setActualSize(fitSize.x, fitSize.y);
                lark.Point.release(fitSize);
            };
            /**
             * 设置组件的布局位置
             */
            p.setLayoutBoundsPosition = function (x, y) {
                var matrix = this.$getMatrix();
                if (!isDeltaIdentity(matrix.$data)) {
                    var bounds = lark.$TempRectangle;
                    this.getLayoutBounds(bounds);
                    x += this.$getX() - bounds.x;
                    y += this.$getY() - bounds.y;
                }
                this.$super.$setX.call(this, x);
                this.$super.$setY.call(this, y);
            };
            /**
             * 组件的布局尺寸,常用于父级的updateDisplayList()方法中
             * 按照：布局尺寸>外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸,
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getLayoutBounds = function (bounds) {
                var values = this.$uiValues;
                var w;
                if (this.$hasFlags(1048576 /* LayoutWidthExplicitlySet */)) {
                    w = values[10 /* width */];
                }
                else if (!lark.isNone(values[8 /* explicitWidth */])) {
                    w = values[8 /* explicitWidth */];
                }
                else {
                    w = values[16 /* measuredWidth */];
                }
                var h;
                if (this.$hasFlags(2097152 /* LayoutHeightExplicitlySet */)) {
                    h = values[11 /* height */];
                }
                else if (!lark.isNone(values[9 /* explicitHeight */])) {
                    h = values[9 /* explicitHeight */];
                }
                else {
                    h = values[17 /* measuredHeight */];
                }
                this.applyMatrix(bounds, w, h);
            };
            p.getPreferredUWidth = function () {
                var values = this.$uiValues;
                return lark.isNone(values[8 /* explicitWidth */]) ? values[16 /* measuredWidth */] : values[8 /* explicitWidth */];
            };
            p.getPreferredUHeight = function () {
                var values = this.$uiValues;
                return lark.isNone(values[9 /* explicitHeight */]) ? values[17 /* measuredHeight */] : values[9 /* explicitHeight */];
            };
            /**
             * 获取组件的首选尺寸,常用于父级的measure()方法中
             * 按照：外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸，
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getPreferredBounds = function (bounds) {
                var w = this.getPreferredUWidth();
                var h = this.getPreferredUHeight();
                this.applyMatrix(bounds, w, h);
            };
            p.applyMatrix = function (bounds, w, h) {
                var bounds = bounds.setTo(0, 0, w, h);
                var matrix = this.$getMatrix();
                var m = matrix.$data;
                if (isDeltaIdentity(m)) {
                    bounds.x += m[4];
                    bounds.y += m[5];
                }
                else {
                    matrix.$transformBounds(bounds);
                }
            };
            return UIComponentImpl;
        })(lark.DisplayObject);
        player.UIComponentImpl = UIComponentImpl;
        UIComponentImpl.prototype.__class__ = "lark.player.UIComponentImpl";
        /**
         * 检查一个函数的方法体是否为空。
         */
        function isEmptyFunction(prototype, key) {
            if (typeof prototype[key] != "function") {
                return false;
            }
            var body = prototype[key].toString();
            var index = body.indexOf("{");
            var lastIndex = body.lastIndexOf("}");
            body = body.substring(index + 1, lastIndex);
            return body.trim() == "";
        }
        /**
         * 自定义类实现UIComponent的步骤：
         * 1.在自定义类的构造函数里调用：player.UIComponentImpl.call(this);
         * 2.拷贝UIComponent接口定义的所有内容(包括注释掉的protected函数)到自定义类，将所有方法都声明为空方法体。
         * 3.在定义类结尾的外部调用player.implementUIComponent()，并传入自定义类。
         * 4.若覆盖了某个UIComponent的方法，需要手动调用UIComponentImpl.prototype["方法名"].call(this);
         * @param descendant 自定义的UIComponent子类
         * @param base 自定义子类继承的父类
         */
        function implementUIComponent(descendant, base, isContainer) {
            for (var property in UIComponentImpl) {
                if (UIComponentImpl.hasOwnProperty(property)) {
                    descendant[property] = UIComponentImpl[property];
                }
            }
            var prototype = descendant.prototype;
            prototype.$super = base.prototype;
            var protoBase = UIComponentImpl.prototype;
            var keys = Object.keys(protoBase);
            var length = keys.length;
            for (var i = 0; i < length; i++) {
                var key = keys[i];
                if (key == "__meta__") {
                    continue;
                }
                if (!prototype.hasOwnProperty(key) || isEmptyFunction(prototype, key)) {
                    var value = Object.getOwnPropertyDescriptor(protoBase, key);
                    Object.defineProperty(prototype, key, value);
                }
            }
            if (isContainer) {
                prototype.$childAdded = function (child, index) {
                    this.invalidateSize();
                    this.invalidateDisplayList();
                };
                prototype.$childRemoved = function (child, index) {
                    this.invalidateSize();
                    this.invalidateDisplayList();
                };
            }
            if (DEBUG) {
                Object.defineProperty(prototype, "preferredWidth", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getPreferredBounds(bounds);
                        return bounds.width;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "preferredHeight", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getPreferredBounds(bounds);
                        return bounds.height;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "preferredX", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getPreferredBounds(bounds);
                        return bounds.x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "preferredY", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getPreferredBounds(bounds);
                        return bounds.y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "layoutBoundsX", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getLayoutBounds(bounds);
                        return bounds.x;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "layoutBoundsY", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getLayoutBounds(bounds);
                        return bounds.y;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "layoutBoundsWidth", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getLayoutBounds(bounds);
                        return bounds.width;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "layoutBoundsHeight", {
                    get: function () {
                        var bounds = lark.$TempRectangle;
                        this.getLayoutBounds(bounds);
                        return bounds.height;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "measuredWidth", {
                    get: function () {
                        return this.$uiValues[16 /* measuredWidth */];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(prototype, "measuredHeight", {
                    get: function () {
                        return this.$uiValues[17 /* measuredHeight */];
                    },
                    enumerable: true,
                    configurable: true
                });
            }
        }
        player.implementUIComponent = implementUIComponent;
    })(player = lark.player || (lark.player = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015; Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms; with or without
//  modification; are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice; this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice; this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES; INCLUDING; BUT NOT LIMITED TO; THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT; INDIRECT;
//  INCIDENTAL; SPECIAL; EXEMPLARY; OR CONSEQUENTIAL DAMAGES (INCLUDING; BUT NOT
//  LIMITED TO; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE; DATA;
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY; WHETHER IN CONTRACT; STRICT LIABILITY; OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE;
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        lark.$locale_strings = lark.$locale_strings || {};
        var locale_strings = lark.$locale_strings;
        locale_strings[2001] = "{0}: EXML file can't be found ";
        locale_strings[2002] = "{0}: invalid XML file:\n{1}";
        locale_strings[2003] = "{0}: the class definitions corresponding to nodes can't be found  \n {1}";
        locale_strings[2004] = "{0}: nodes cannot contain id property with the same name \n {1}";
        locale_strings[2005] = "{0}: property with the name of '{1}' or style name does not exist on the node: \n {2}";
        locale_strings[2006] = "{0}: undefined view state name: '{1}' \n {2}";
        locale_strings[2007] = "{0}: only egret.IVisualElement objects within the container can use the includeIn and excludeFrom properties\n {1}";
        locale_strings[2008] = "{0}: fail to assign values of '{1}' class to property: '{2}' \n {3}";
        locale_strings[2009] = "{0}: only one ID can be referenced in the node property value '{}' label; and complex expression is not allowed to use \n {1}";
        locale_strings[2010] = "{0}: ID referenced by property: '{1}':  '{2}' does not exist \n {3}";
        locale_strings[2011] = "{0}: fail to assign more than one child nodes to the same property: '{1}' \n {2}";
        locale_strings[2012] = "{0}: no default property exists on the node; and you must explicitly declare the property name that the child node  is assigned to \n {1}";
        locale_strings[2013] = "{0}: view state grammar is not allowed to use on property nodes of Array class \n {1} ";
        locale_strings[2014] = "{0}: assigning the skin class itself to the node property is not allowed \n {1}";
        locale_strings[2015] = "{0}: class definition referenced by node: {1} does not exist \n {2}";
        locale_strings[2016] = "{0}: format error of 'scale9Grid' property value on the node: {1}";
        locale_strings[2017] = "{0}: namespace prefix missing on the node: {1}";
        locale_strings[2018] = "{0}: format error of 'skinName' property value on the node: {1}";
        locale_strings[2019] = "{0}: the container’s child item must be visible nodes: {1}";
        locale_strings[2020] = "{0}: for child nodes in w: Declarations, the includeIn and excludeFrom properties are not allowed to use \n {1}";
        locale_strings[2102] = "{0}: no child node can be found on the property code \n {1}";
        locale_strings[2103] = "{0}: the same property '{1}' on the node is assigned multiple times \n {2}";
        locale_strings[2104] = "Instantiate class {0} error，the parameters of its constructor method must be empty.";
        locale_strings[2201] = "BasicLayout doesn't support virtualization.";
        locale_strings[2202] = "parse skinName error，the parsing result of skinName must be a instance of lark.gui.Skin.";
        locale_strings[2203] = "parse source error，could not find asset from URL：{0} .";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015; Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms; with or without
//  modification; are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice; this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice; this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES; INCLUDING; BUT NOT LIMITED TO; THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT; INDIRECT;
//  INCIDENTAL; SPECIAL; EXEMPLARY; OR CONSEQUENTIAL DAMAGES (INCLUDING; BUT NOT
//  LIMITED TO; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE; DATA;
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY; WHETHER IN CONTRACT; STRICT LIABILITY; OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE;
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        lark.$locale_strings = lark.$locale_strings || {};
        var locale_strings = lark.$locale_strings;
        //EXML报错信息
        locale_strings[2001] = "{0}: 找不到EXML文件";
        locale_strings[2002] = "{0}: 不是有效的XML文件:\n{1}";
        locale_strings[2003] = "{0}: 无法找到节点所对应的类定义\n{1}";
        locale_strings[2004] = "{0}: 节点不能含有同名的id属性\n{1}";
        locale_strings[2005] = "{0}: 节点上不存在名为'{1}'的属性或样式名:\n{2}";
        locale_strings[2006] = "{0}: 未定义的视图状态名称:'{1}'\n{2}";
        locale_strings[2007] = "{0}: 只有处于容器内的egret.IVisualElement对象可以使用includeIn和excludeFrom属性\n{1}";
        locale_strings[2008] = "{0}: 无法将'{1}'类型的值赋给属性:'{2}'\n{3}";
        locale_strings[2009] = "{0}: 在节点属性值的‘{}’标签内只能引用一个ID，不允许使用复杂表达式\n{1}";
        locale_strings[2010] = "{0}: 属性:'{1}'所引用的ID: '{2}'不存在\n{3}";
        locale_strings[2011] = "{0}: 无法将多个子节点赋值给同一个属性:'{1}'\n{2}";
        locale_strings[2012] = "{0}: 节点上不存在默认属性，必须显式声明子节点要赋值到的属性名\n{1}";
        locale_strings[2013] = "{0}: 类型为Array的属性节点上不允许使用视图状态语法\n{1}";
        locale_strings[2014] = "{0}: 不允许将皮肤类自身赋值给节点属性\n{1}";
        locale_strings[2015] = "{0}: 节点引用的类定义:{1}不存在\n{2}";
        locale_strings[2016] = "{0}: 节点上'scale9Grid'属性值的格式错误:{1}";
        locale_strings[2017] = "{0}: 节点上缺少命名空间前缀:{1}";
        locale_strings[2018] = "{0}: 节点上'skinName'属性值的格式错误:{1}";
        locale_strings[2019] = "{0}: 容器的子项必须是可视节点:{1}";
        locale_strings[2020] = "{0}: 在w:Declarations内的子节点，不允许使用includeIn和excludeFrom属性\n{1}";
        //EXML警告信息
        locale_strings[2102] = "{0}: 在属性节点上找不到任何子节点\n{1}";
        locale_strings[2103] = "{0}: 节点上的同一个属性'{1}'被多次赋值\n{2}";
        locale_strings[2104] = "无法实例化组件：{0} ，请检查该组件构造函数参数是否为空。";
        //GUI报错信息
        locale_strings[2201] = "BasicLayout 不支持虚拟化。";
        locale_strings[2202] = "皮肤解析出错，skinName 属性的值必须要能够解析为一个Skin子类的实例。";
        locale_strings[2203] = "素材解析出错，找不到URL：{0} 所对应的资源。";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        var parser = new lark.player.EXMLParser();
        /**
         * EXML皮肤文件运行时解析工具
         */
        var EXML = (function () {
            function EXML() {
            }var d = __define,c=EXML;p=c.prototype;
            /**
             * 解析一个EXML文件的文本内容为一个皮肤类。
             * @param text 要解析的EXML文件内容
             * @param className 皮肤对应的完整类名，包括模块名称。例如 lark.gui.ButtonSkin。解析完成后皮肤类定义会自动缓存到全局，
             * 若指定的类已经存在，将会覆盖已有的类定义。解析后您也可以通过lark.getDefinitionByName(className)方法获取这个皮肤的类定义。
             */
            EXML.parse = function (text, className) {
                if (DEBUG) {
                    if (!text) {
                        lark.$error(1003, "text");
                    }
                    if (!className) {
                        lark.$error(1003, "className");
                    }
                }
                try {
                    var xml = lark.player.XML.parse(text);
                }
                catch (e) {
                    if (DEBUG) {
                        lark.$error(2002, className, text + "\n" + e.message);
                    }
                }
                var code = parser.parse(xml, className);
                try {
                    var clazz = eval(code);
                }
                catch (e) {
                    if (DEBUG) {
                        lark.log(code);
                    }
                    return null;
                }
                if (className && clazz) {
                    var paths = className.split(".");
                    var length = paths.length;
                    var definition = __global;
                    for (var i = 0; i < length - 1; i++) {
                        var path = paths[i];
                        definition = definition[path] || (definition[path] = {});
                    }
                    definition[paths[length - 1]] = clazz;
                }
                return clazz;
            };
            return EXML;
        })();
        gui.EXML = EXML;
        EXML.prototype.__class__ = "lark.gui.EXML";
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 默认的皮肤适配器
         */
        var assetAdapter = new gui.DefaultAssetAdapter();
        /**
         * Image 控件允许您在运行时显示 JPEG、PNG 等图片文件文件。Image 继承至 Bitmap，因此您可以直接对其 bitmapData 属性，
         * 赋值从外部加载得到的位图数据以显示对应图片。同时，Image 还提供了更加方便的 source 属性，source 属性可以接受一个网络图片url作为值，
         * 赋值为url后，它内部会自动去加载并显示图片。并且您同样也可以直接把 BitmapData 对象赋值给 source 属性以显示图片。
         * Image 控件可以直接替代 Bitmap 在显示列表中使用。
         *
         * @event lark.Event.COMPLETE 当图片加载完成后调度
         */
        var Image = (function (_super) {
            __extends(Image, _super);
            function Image(source) {
                _super.call(this);
                /**
                 * 矩形区域，它定义素材对象的九个缩放区域。
                 * 注意:此属性仅在fileMode为BitmapFillMode.SCALE时有效。
                 */
                this._scale9Grid = null;
                this._fillMode = "scale";
                this.sourceChanged = false;
                this._source = null;
                lark.player.UIComponentImpl.call(this);
                if (source) {
                    this.source = source;
                }
            }var d = __define,c=Image;p=c.prototype;
            d(p, "scale9Grid", {
                g: function () {
                    return this._scale9Grid;
                },
                s: function (value) {
                    this._scale9Grid = value;
                    this.invalidateDisplayList();
                },
            });
            d(p, "fillMode", {
                /**
                 * 确定位图填充尺寸的方式。默认值：BitmapFillMode.SCALE。
                 * 设置为 BitmapFillMode.CLIP，位图将在边缘处被截断。
                 * 设置为 BitmapFillMode.REPEAT时，位图将重复以填充区域。
                 * 设置为 BitmapFillMode.SCALE时，位图将拉伸以填充区域。
                 */
                g: function () {
                    return this._fillMode;
                },
                s: function (value) {
                    if (value == this._fillMode) {
                        return;
                    }
                    this._fillMode = value;
                    this.invalidateDisplayList();
                },
            });
            d(p, "source", {
                /**
                 * 用于显示位图的数据源。可以为一个网络图片url或BitmapData实例。
                 */
                g: function () {
                    return this._source;
                },
                s: function (value) {
                    if (value == this._source) {
                        return;
                    }
                    this._source = value;
                    if (!value) {
                        this.$setBitmapData(null);
                    }
                    else if (typeof value == "string") {
                        if (this.$stage) {
                            this.parseSource();
                        }
                        else {
                            this.sourceChanged = true;
                        }
                    }
                    else {
                        this.$setBitmapData(value);
                    }
                },
            });
            p.$setBitmapData = function (value) {
                if (value === this.$bitmapData) {
                    return;
                }
                _super.prototype.$setBitmapData.call(this, value);
                this._source = value;
                this.sourceChanged = false;
                this.invalidateSize();
                this.invalidateDisplayList();
            };
            p.$onAddToStage = function (stage, nestLevel) {
                _super.prototype.$onAddToStage.call(this, stage, nestLevel);
                this.checkInvalidateFlag();
                if (this.sourceChanged) {
                    this.parseSource();
                }
            };
            /**
             * 解析source
             */
            p.parseSource = function () {
                this.sourceChanged = false;
                if (!assetAdapter) {
                    assetAdapter = this.getAdapter();
                }
                assetAdapter.getAsset(this._source, this.contentChanged, this);
            };
            /**
             * 获取资源适配器
             */
            p.getAdapter = function () {
                var adapter = this.$stage.getImplementation("lark.gui.IAssetAdapter");
                if (!adapter) {
                    adapter = new gui.DefaultAssetAdapter();
                }
                return adapter;
            };
            /**
             * 资源发生改变
             */
            p.contentChanged = function (data, source) {
                if (source !== this._source)
                    return;
                if (!lark.is(data, 7 /* BitmapData */)) {
                    return;
                }
                this.$setBitmapData(data);
                if (data) {
                    this.emitWith(lark.Event.COMPLETE);
                }
                else if (DEBUG) {
                    lark.$warn(2203, source);
                }
            };
            p.$measureContentBounds = function (bounds) {
                var bitmapData = this.$bitmapData;
                if (bitmapData) {
                    var values = this.$uiValues;
                    var width = values[10 /* width */];
                    var height = values[11 /* height */];
                    if (lark.isNone(width) || lark.isNone(height)) {
                        bounds.setEmpty();
                        return;
                    }
                    if (this._fillMode == "clip") {
                        if (width > bitmapData.width) {
                            width = bitmapData.width;
                        }
                        if (height > bitmapData.height) {
                            height = bitmapData.height;
                        }
                    }
                    bounds.setTo(0, 0, width, height);
                }
                else {
                    bounds.setEmpty();
                }
            };
            p.$render = function (context) {
                var bitmapData = this.$bitmapData;
                if (!bitmapData) {
                    return;
                }
                var values = this.$uiValues;
                var width = values[10 /* width */];
                var height = values[11 /* height */];
                if (lark.isNone(width) || lark.isNone(height)) {
                    return;
                }
                switch (this._fillMode) {
                    case "clip":
                        if (width > bitmapData.width) {
                            width = bitmapData.width;
                        }
                        if (height > bitmapData.height) {
                            height = bitmapData.height;
                        }
                        context.drawImage(bitmapData, 0, 0, width, height, 0, 0, width, height);
                        break;
                    case "repeat":
                        var pattern = context.createPattern(bitmapData, "repeat");
                        context.rect(0, 0, width, height);
                        context.fillStyle = pattern;
                        context.fill();
                        break;
                    default:
                        context.imageSmoothingEnabled = this.$smoothing;
                        if (this._scale9Grid) {
                            this.drawScale9GridImage(context, bitmapData, this._scale9Grid, width, height);
                        }
                        else {
                            context.drawImage(bitmapData, 0, 0, width, height);
                        }
                        break;
                }
            };
            /**
             * 绘制九宫格位图
             */
            p.drawScale9GridImage = function (context, image, scale9Grid, surfaceWidth, surfaceHeight) {
                var imageWidth = image.width;
                var imageHeight = image.height;
                var sourceW0 = scale9Grid.x;
                var sourceH0 = scale9Grid.y;
                var sourceW1 = scale9Grid.width;
                var sourceH1 = scale9Grid.height;
                //防止空心的情况出现。
                if (sourceH1 == 0) {
                    sourceH1 = 1;
                    if (sourceH0 >= imageHeight) {
                        sourceH0--;
                    }
                }
                if (sourceW1 == 0) {
                    sourceW1 = 1;
                    if (sourceW0 >= imageWidth) {
                        sourceW0--;
                    }
                }
                var sourceX0 = 0;
                var sourceX1 = sourceX0 + sourceW0;
                var sourceX2 = sourceX1 + sourceW1;
                var sourceW2 = imageWidth - sourceW0 - sourceW1;
                var sourceY0 = 0;
                var sourceY1 = sourceY0 + sourceH0;
                var sourceY2 = sourceY1 + sourceH1;
                var sourceH2 = imageHeight - sourceH0 - sourceH1;
                var targetX0 = 0;
                var targetX1 = targetX0 + sourceW0;
                var targetX2 = targetX0 + surfaceWidth - sourceW2;
                var targetW1 = surfaceWidth - sourceW0 - sourceW2;
                var targetY0 = 0;
                var targetY1 = targetY0 + sourceH0;
                var targetY2 = targetY0 + surfaceHeight - sourceH2;
                var targetH1 = surfaceHeight - sourceH0 - sourceH2;
                //
                //             x0     x1     x2
                //          y0 +------+------+------+
                //             |      |      |      | h0
                //             |      |      |      |
                //          y1 +------+------+------+
                //             |      |      |      | h1
                //             |      |      |      |
                //          y2 +------+------+------+
                //             |      |      |      | h2
                //             |      |      |      |
                //             +------+------+------+
                //                w0     w1     w2
                //
                context.drawImage(image, sourceX0, sourceY0, sourceW0, sourceH0, targetX0, targetY0, sourceW0, sourceH0);
                context.drawImage(image, sourceX1, sourceY0, sourceW1, sourceH0, targetX1, targetY0, targetW1, sourceH0);
                context.drawImage(image, sourceX2, sourceY0, sourceW2, sourceH0, targetX2, targetY0, sourceW2, sourceH0);
                context.drawImage(image, sourceX0, sourceY1, sourceW0, sourceH1, targetX0, targetY1, sourceW0, targetH1);
                context.drawImage(image, sourceX1, sourceY1, sourceW1, sourceH1, targetX1, targetY1, targetW1, targetH1);
                context.drawImage(image, sourceX2, sourceY1, sourceW2, sourceH1, targetX2, targetY1, sourceW2, targetH1);
                context.drawImage(image, sourceX0, sourceY2, sourceW0, sourceH2, targetX0, targetY2, sourceW0, sourceH2);
                context.drawImage(image, sourceX1, sourceY2, sourceW1, sourceH2, targetX1, targetY2, targetW1, sourceH2);
                context.drawImage(image, sourceX2, sourceY2, sourceW2, sourceH2, targetX2, targetY2, sourceW2, sourceH2);
            };
            //=======================UIComponent接口实现===========================
            /**
             * 创建子项,子类覆盖此方法以完成组件子项的初始化操作，
             * 请务必调用super.createChildren()以完成父类组件的初始化
             */
            p.createChildren = function () {
            };
            /**
             * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
             */
            p.commitProperties = function () {
            };
            /**
             * 测量组件尺寸
             */
            p.measure = function () {
                var bitmapData = this.$bitmapData;
                if (bitmapData) {
                    this.setMeasuredSize(bitmapData.width, bitmapData.height);
                }
                else {
                    this.setMeasuredSize(0, 0);
                }
            };
            /**
             * 更新显示列表
             */
            p.updateDisplayList = function (unscaledWidth, unscaledHeight) {
                this.$invalidateContentBounds();
            };
            /**
             * 标记父级容器的尺寸和显示列表为失效
             */
            p.invalidateParentLayout = function () {
            };
            /**
             * 设置测量结果。
             * @param width 测量宽度
             * @param height 测量高度
             */
            p.setMeasuredSize = function (width, height) {
            };
            /**
             * 标记提交过需要延迟应用的属性
             */
            p.invalidateProperties = function () {
            };
            /**
             * 验证组件的属性
             */
            p.validateProperties = function () {
            };
            /**
             * 标记提交过需要验证组件尺寸
             */
            p.invalidateSize = function () {
            };
            /**
             * 验证组件的尺寸
             */
            p.validateSize = function (recursive) {
            };
            /**
             * 标记需要验证显示列表
             */
            p.invalidateDisplayList = function () {
            };
            /**
             * 验证子项的位置和大小，并绘制其他可视内容
             */
            p.validateDisplayList = function () {
            };
            /**
             * 立即应用组件及其子项的所有属性
             */
            p.validateNow = function () {
            };
            /**
             * 设置组件的布局宽高
             */
            p.setLayoutBoundsSize = function (layoutWidth, layoutHeight) {
            };
            /**
             * 设置组件的布局位置
             */
            p.setLayoutBoundsPosition = function (x, y) {
            };
            /**
             * 组件的布局尺寸,常用于父级的updateDisplayList()方法中
             * 按照：布局尺寸>外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸,
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getLayoutBounds = function (bounds) {
            };
            /**
             * 获取组件的首选尺寸,常用于父级的measure()方法中
             * 按照：外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸，
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getPreferredBounds = function (bounds) {
            };
            return Image;
        })(lark.Bitmap);
        gui.Image = Image;
        Image.prototype.__class__ = "lark.gui.Image";
        lark.player.implementUIComponent(Image, lark.Bitmap);
        lark.registerClass(Image, 1005 /* Image */, [1001 /* UIComponent */]);
        gui.registerProperty(Image, "scale9Grid", "lark.Rectangle");
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * GUI容器基类
         */
        var Group = (function (_super) {
            __extends(Group, _super);
            function Group() {
                _super.call(this);
                this.$elementsContent = [];
                this._layout = null;
                lark.player.UIComponentImpl.call(this);
            }var d = __define,c=Group;p=c.prototype;
            d(p, "elementsContent", {
                s: function (value) {
                    this.$elementsContent = value;
                    this.removeChildren();
                    if (value) {
                        var length = value.length;
                        for (var i = 0; i < length; i++) {
                            this.addChild(value[i]);
                        }
                    }
                },
            });
            d(p, "layout", {
                /**
                 * 此容器的布局对象
                 */
                g: function () {
                    return this._layout;
                },
                s: function (value) {
                    this.$setLayout(value);
                },
            });
            p.$setLayout = function (value) {
                if (this._layout == value)
                    return;
                if (this._layout) {
                    this._layout.target = null;
                }
                this._layout = value;
                if (value) {
                    value.target = this;
                }
                this.invalidateSize();
                this.invalidateDisplayList();
                this.emitWith("layoutChanged");
            };
            d(p, "contentWidth", {
                /**
                 * 视域的内容的宽度
                 */
                g: function () {
                    return this.$uiValues[20 /* contentWidth */];
                },
            });
            d(p, "contentHeight", {
                /**
                 * 视域的内容的高度
                 */
                g: function () {
                    return this.$uiValues[21 /* contentHeight */];
                },
            });
            /**
             * 设置 contentWidth 和 contentHeight 属性，此方法由Layout类调用
             */
            p.setContentSize = function (width, height) {
                width = Math.ceil(+width || 0);
                height = Math.ceil(+height || 0);
                var values = this.$uiValues;
                if (values[20 /* contentWidth */] === width && values[21 /* contentHeight */] === height) {
                    return;
                }
                values[20 /* contentWidth */] = width;
                values[21 /* contentHeight */] = height;
                gui.UIEvent.emitUIEvent(this, gui.UIEvent.CONTENT_SIZE_CHANGED);
            };
            d(p, "scrollEnabled", {
                /**
                 * 是否启用容器滚动。如果为 true，则将子项剪切到视区的边界，配合设置scrollH和scrollV属性将能滚动视区。
                 * 如果为 false，则容器子代会从容器边界扩展过去，而设置scrollH和scrollV也无效。默认false。
                 */
                g: function () {
                    return this.$hasFlags(4194304 /* scrollEnabled */);
                },
                s: function (value) {
                    value = !!value;
                    if (value === this.$hasFlags(4194304 /* scrollEnabled */))
                        return;
                    this.$toggleFlags(4194304 /* scrollEnabled */, value);
                    this.updateScrollRect();
                },
            });
            d(p, "scrollH", {
                /**
                 * 可视区域水平方向起始点
                 */
                g: function () {
                    return this.$uiValues[22 /* scrollH */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (value === values[22 /* scrollH */])
                        return;
                    values[22 /* scrollH */] = value;
                    if (this.updateScrollRect() && this._layout) {
                        this._layout.scrollPositionChanged();
                    }
                    gui.UIEvent.emitUIEvent(this, gui.UIEvent.SCROLL_POSITION_CHANGED);
                },
            });
            d(p, "scrollV", {
                /**
                 * 可视区域竖直方向起始点
                 */
                g: function () {
                    return this.$uiValues[23 /* scrollV */];
                },
                s: function (value) {
                    value = +value || 0;
                    var values = this.$uiValues;
                    if (value == values[23 /* scrollV */])
                        return;
                    values[23 /* scrollV */] = value;
                    if (this.updateScrollRect() && this._layout) {
                        this._layout.scrollPositionChanged();
                    }
                    gui.UIEvent.emitUIEvent(this, gui.UIEvent.SCROLL_POSITION_CHANGED);
                },
            });
            p.updateScrollRect = function () {
                var values = this.$uiValues;
                var hasClip = this.$hasFlags(4194304 /* scrollEnabled */);
                if (hasClip) {
                    this.scrollRect = lark.$TempRectangle.setTo(values[22 /* scrollH */], values[23 /* scrollV */], values[10 /* width */], values[11 /* height */]);
                }
                else if (this.$scrollRect) {
                    this.scrollRect = null;
                }
                return hasClip;
            };
            //=======================UIComponent接口实现===========================
            /**
             * 创建子项,子类覆盖此方法以完成组件子项的初始化操作，
             * 请务必调用super.createChildren()以完成父类组件的初始化
             */
            p.createChildren = function () {
                if (!this._layout) {
                    this.$setLayout(new gui.BasicLayout());
                }
            };
            /**
             * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
             */
            p.commitProperties = function () {
            };
            /**
             * 测量组件尺寸
             */
            p.measure = function () {
                if (!this._layout) {
                    this.setMeasuredSize(0, 0);
                    return;
                }
                this._layout.measure();
            };
            /**
             * 更新显示列表
             */
            p.updateDisplayList = function (unscaledWidth, unscaledHeight) {
                if (this._layout) {
                    this._layout.updateDisplayList(unscaledWidth, unscaledHeight);
                }
                this.updateScrollRect();
            };
            /**
             * 标记父级容器的尺寸和显示列表为失效
             */
            p.invalidateParentLayout = function () {
            };
            /**
             * 设置测量结果。
             * @param width 测量宽度
             * @param height 测量高度
             */
            p.setMeasuredSize = function (width, height) {
            };
            /**
             * 标记提交过需要延迟应用的属性
             */
            p.invalidateProperties = function () {
            };
            /**
             * 验证组件的属性
             */
            p.validateProperties = function () {
            };
            /**
             * 标记提交过需要验证组件尺寸
             */
            p.invalidateSize = function () {
            };
            /**
             * 验证组件的尺寸
             */
            p.validateSize = function (recursive) {
            };
            /**
             * 标记需要验证显示列表
             */
            p.invalidateDisplayList = function () {
            };
            /**
             * 验证子项的位置和大小，并绘制其他可视内容
             */
            p.validateDisplayList = function () {
            };
            /**
             * 立即应用组件及其子项的所有属性
             */
            p.validateNow = function () {
            };
            /**
             * 设置组件的布局宽高
             */
            p.setLayoutBoundsSize = function (layoutWidth, layoutHeight) {
            };
            /**
             * 设置组件的布局位置
             */
            p.setLayoutBoundsPosition = function (x, y) {
            };
            /**
             * 组件的布局尺寸,常用于父级的updateDisplayList()方法中
             * 按照：布局尺寸>外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸,
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getLayoutBounds = function (bounds) {
            };
            /**
             * 获取组件的首选尺寸,常用于父级的measure()方法中
             * 按照：外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸，
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getPreferredBounds = function (bounds) {
            };
            return Group;
        })(lark.Sprite);
        gui.Group = Group;
        Group.prototype.__class__ = "lark.gui.Group";
        lark.player.implementUIComponent(Group, lark.Sprite, true);
        lark.registerClass(Group, 1002 /* Group */, [1001 /* UIComponent */]);
        gui.registerProperty(Group, "elementsContent", "Array", true);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        var UIImpl = lark.player.UIComponentImpl;
        /**
         * Label 是可以呈示一行或多行统一格式文本的UI组件。要显示的文本由 text 属性确定。文本格式由样式属性指定，例如 fontFamily 和 fontSize。
         * 因为 Label 运行速度快且占用内存少，所以它特别适合用于显示多个小型非交互式文本的情况，例如，项呈示器和 Button 外观中的标签。
         * 在 Label 中，将以下三个字符序列识别为显式换行符：CR（“\r”）、LF（“\n”）和 CR+LF（“\r\n”）。
         * 如果没有为 Label 指定宽度，则由这些显式换行符确定的最长行确定 Label 的宽度。
         * 如果指定了宽度，则指定文本将在组件边界的右边缘换行，如果文本扩展到低于组件底部，则将被剪切。
         */
        var Label = (function (_super) {
            __extends(Label, _super);
            function Label(text) {
                _super.call(this, text);
                this._widthConstraint = lark.NONE;
                UIImpl.call(this);
            }var d = __define,c=Label;p=c.prototype;
            p.$invalidateContentBounds = function () {
                _super.prototype.$invalidateContentBounds.call(this);
                this.invalidateSize();
            };
            p.$setWidth = function (value) {
                _super.prototype.$setWidth.call(this, value);
                UIImpl.prototype.$setWidth.call(this, value);
            };
            p.$setHeight = function (value) {
                _super.prototype.$setHeight.call(this, value);
                UIImpl.prototype.$setHeight.call(this, value);
            };
            //=======================UIComponent接口实现===========================
            /**
             * 创建子项,子类覆盖此方法以完成组件子项的初始化操作，
             * 请务必调用super.createChildren()以完成父类组件的初始化
             */
            p.createChildren = function () {
            };
            /**
             * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
             */
            p.commitProperties = function () {
            };
            /**
             * 测量组件尺寸
             */
            p.measure = function () {
                var values = this.$uiValues;
                var textValues = this.$textFieldValues;
                var oldWidth = textValues[3 /* textFieldWidth */];
                var availableWidth = lark.NONE;
                if (!lark.isNone(this._widthConstraint)) {
                    availableWidth = this._widthConstraint;
                    this._widthConstraint = lark.NONE;
                }
                else if (!lark.isNone(values[8 /* explicitWidth */])) {
                    availableWidth = values[8 /* explicitWidth */];
                }
                else if (values[13 /* maxWidth */] != 100000) {
                    availableWidth = values[13 /* maxWidth */];
                }
                _super.prototype.$setWidth.call(this, availableWidth);
                this.setMeasuredSize(this.textWidth, this.textHeight);
                _super.prototype.$setWidth.call(this, oldWidth);
            };
            /**
             * 更新显示列表
             */
            p.updateDisplayList = function (unscaledWidth, unscaledHeight) {
                _super.prototype.$setWidth.call(this, unscaledWidth);
                _super.prototype.$setHeight.call(this, unscaledHeight);
            };
            /**
             * 标记父级容器的尺寸和显示列表为失效
             */
            p.invalidateParentLayout = function () {
            };
            /**
             * 设置测量结果。
             * @param width 测量宽度
             * @param height 测量高度
             */
            p.setMeasuredSize = function (width, height) {
            };
            /**
             * 标记提交过需要延迟应用的属性
             */
            p.invalidateProperties = function () {
            };
            /**
             * 验证组件的属性
             */
            p.validateProperties = function () {
            };
            /**
             * 标记提交过需要验证组件尺寸
             */
            p.invalidateSize = function () {
            };
            /**
             * 验证组件的尺寸
             */
            p.validateSize = function (recursive) {
            };
            /**
             * 标记需要验证显示列表
             */
            p.invalidateDisplayList = function () {
            };
            /**
             * 验证子项的位置和大小，并绘制其他可视内容
             */
            p.validateDisplayList = function () {
            };
            /**
             * 立即应用组件及其子项的所有属性
             */
            p.validateNow = function () {
            };
            /**
             * 设置组件的布局宽高
             */
            p.setLayoutBoundsSize = function (layoutWidth, layoutHeight) {
                UIImpl.prototype.setLayoutBoundsSize.call(this, layoutWidth, layoutHeight);
                if (lark.isNone(layoutWidth) || layoutWidth === this._widthConstraint || layoutWidth == 0) {
                    return;
                }
                var values = this.$uiValues;
                if (!lark.isNone(values[9 /* explicitHeight */])) {
                    return;
                }
                if (layoutWidth == values[16 /* measuredWidth */]) {
                    return;
                }
                this._widthConstraint = layoutWidth;
                this.invalidateSize();
            };
            /**
             * 设置组件的布局位置
             */
            p.setLayoutBoundsPosition = function (x, y) {
            };
            /**
             * 组件的布局尺寸,常用于父级的updateDisplayList()方法中
             * 按照：布局尺寸>外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸,
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getLayoutBounds = function (bounds) {
            };
            /**
             * 获取组件的首选尺寸,常用于父级的measure()方法中
             * 按照：外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸，
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getPreferredBounds = function (bounds) {
            };
            return Label;
        })(lark.TextField);
        gui.Label = Label;
        Label.prototype.__class__ = "lark.gui.Label";
        lark.player.implementUIComponent(Label, lark.TextField);
        lark.registerClass(Label, 1004 /* Label */, [1001 /* UIComponent */]);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * BasicLayout 类根据其各个设置彼此独立地排列布局元素。
         * BasicLayout（也称为绝对布局）要求显式定位每个容器子代。可以使用子代的 x 和 y 属性，或使用约束来定位每个子代。
         */
        var BasicLayout = (function (_super) {
            __extends(BasicLayout, _super);
            /**
             * 创建一个基本布局实例
             */
            function BasicLayout() {
                _super.call(this);
            }var d = __define,c=BasicLayout;p=c.prototype;
            /**
             *基于目标的内容测量其默认大小，并（可选）测量目标的默认最小大小
             */
            p.measure = function () {
                _super.prototype.measure.call(this);
                lark.player.measure(this.$target);
            };
            /**
             * 调整目标的元素的大小并定位这些元素
             * @param unscaledWidth
             * @param unscaledHeight
             */
            p.updateDisplayList = function (unscaledWidth, unscaledHeight) {
                _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
                var target = this.$target;
                var pos = lark.player.updateDisplayList(target, unscaledWidth, unscaledHeight);
                target.setContentSize(Math.ceil(pos.x), Math.ceil(pos.y));
            };
            return BasicLayout;
        })(gui.LayoutBase);
        gui.BasicLayout = BasicLayout;
        BasicLayout.prototype.__class__ = "lark.gui.BasicLayout";
        if (DEBUG) {
            Object.defineProperty(BasicLayout.prototype, "useVirtualLayout", {
                /**
                 * 此布局不支持虚拟布局，设置这个属性无效
                 */
                get: function () {
                    return this.$useVirtualLayout;
                },
                set: function (value) {
                    lark.$error(2201);
                },
                enumerable: true,
                configurable: true
            });
        }
        lark.registerClass(BasicLayout, 1010 /* BasicLayout */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
var lark;
(function (lark) {
    var player;
    (function (player) {
        /**
         * 一个工具方法，使用BasicLayout规则测量目标对象。
         */
        function measure(target) {
            if (!target) {
                return;
            }
            var width = 0;
            var height = 0;
            var bounds = lark.$TempRectangle;
            var count = target.numChildren;
            for (var i = 0; i < count; i++) {
                var layoutElement = (target.getChildAt(i));
                if (!lark.is(layoutElement, 1001 /* UIComponent */) || !layoutElement.$includeInLayout) {
                    continue;
                }
                var values = layoutElement.$uiValues;
                var hCenter = values[4 /* horizontalCenter */];
                var vCenter = values[5 /* verticalCenter */];
                var left = values[0 /* left */];
                var right = values[1 /* right */];
                var top = values[2 /* top */];
                var bottom = values[3 /* bottom */];
                var extX;
                var extY;
                layoutElement.getPreferredBounds(bounds);
                if (!lark.isNone(left) && !lark.isNone(right)) {
                    extX = left + right;
                }
                else if (!lark.isNone(hCenter)) {
                    extX = Math.abs(hCenter) * 2;
                }
                else if (!lark.isNone(left) || !lark.isNone(right)) {
                    extX = lark.isNone(left) ? 0 : left;
                    extX += lark.isNone(right) ? 0 : right;
                }
                else {
                    extX = bounds.x;
                }
                if (!lark.isNone(top) && !lark.isNone(bottom)) {
                    extY = top + bottom;
                }
                else if (!lark.isNone(vCenter)) {
                    extY = Math.abs(vCenter) * 2;
                }
                else if (!lark.isNone(top) || !lark.isNone(bottom)) {
                    extY = lark.isNone(top) ? 0 : top;
                    extY += lark.isNone(bottom) ? 0 : bottom;
                }
                else {
                    extY = bounds.y;
                }
                var preferredWidth = bounds.width;
                var preferredHeight = bounds.height;
                width = Math.ceil(Math.max(width, extX + preferredWidth));
                height = Math.ceil(Math.max(height, extY + preferredHeight));
            }
            target.setMeasuredSize(width, height);
        }
        player.measure = measure;
        /**
         * 一个工具方法，使用BasicLayout规则布局目标对象。
         */
        function updateDisplayList(target, unscaledWidth, unscaledHeight) {
            if (!target)
                return;
            var count = target.numChildren;
            var maxX = 0;
            var maxY = 0;
            var bounds = lark.$TempRectangle;
            for (var i = 0; i < count; i++) {
                var layoutElement = (target.getChildAt(i));
                if (!lark.is(layoutElement, 1001 /* UIComponent */) || !layoutElement.$includeInLayout) {
                    continue;
                }
                var values = layoutElement.$uiValues;
                var hCenter = values[4 /* horizontalCenter */];
                var vCenter = values[5 /* verticalCenter */];
                var left = values[0 /* left */];
                var right = values[1 /* right */];
                var top = values[2 /* top */];
                var bottom = values[3 /* bottom */];
                var percentWidth = values[6 /* percentWidth */];
                var percentHeight = values[7 /* percentHeight */];
                var childWidth = lark.NONE;
                var childHeight = lark.NONE;
                if (!lark.isNone(left) && !lark.isNone(right)) {
                    childWidth = unscaledWidth - right - left;
                }
                else if (!lark.isNone(percentWidth)) {
                    childWidth = Math.round(unscaledWidth * Math.min(percentWidth * 0.01, 1));
                }
                if (!lark.isNone(top) && !lark.isNone(bottom)) {
                    childHeight = unscaledHeight - bottom - top;
                }
                else if (!lark.isNone(percentHeight)) {
                    childHeight = Math.round(unscaledHeight * Math.min(percentHeight * 0.01, 1));
                }
                layoutElement.setLayoutBoundsSize(childWidth, childHeight);
                layoutElement.getLayoutBounds(bounds);
                var elementWidth = bounds.width;
                var elementHeight = bounds.height;
                var childX = lark.NONE;
                var childY = lark.NONE;
                if (!lark.isNone(hCenter))
                    childX = Math.round((unscaledWidth - elementWidth) / 2 + hCenter);
                else if (!lark.isNone(left))
                    childX = left;
                else if (!lark.isNone(right))
                    childX = unscaledWidth - elementWidth - right;
                else
                    childX = bounds.x;
                if (!lark.isNone(vCenter))
                    childY = Math.round((unscaledHeight - elementHeight) / 2 + vCenter);
                else if (!lark.isNone(top))
                    childY = top;
                else if (!lark.isNone(bottom))
                    childY = unscaledHeight - elementHeight - bottom;
                else
                    childY = bounds.y;
                layoutElement.setLayoutBoundsPosition(childX, childY);
                maxX = Math.max(maxX, childX + elementWidth);
                maxY = Math.max(maxY, childY + elementHeight);
            }
            return lark.$TempPoint.setTo(maxX, maxY);
        }
        player.updateDisplayList = updateDisplayList;
    })(player = lark.player || (lark.player = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * Component 类定义可设置外观的组件的基类。Component 类所使用的外观通常是 Skin 类的子类。
         */
        var Component = (function (_super) {
            __extends(Component, _super);
            function Component() {
                _super.call(this);
                /**
                 * 主机组件标识符。用于唯一确定一个组件的名称。
                 * 用户自定义的组件若不对此属性赋值，将会继承父级的标识符定义。
                 */
                this.hostComponentKey = null;
                this._skinName = null;
                this.$skin = null;
                //========================皮肤视图状态=====================start=======================
                this.explicitCurrentState = "";
                lark.player.UIComponentImpl.call(this);
            }var d = __define,c=Component;p=c.prototype;
            d(p, "skinName", {
                /**
                 * 皮肤标识符。有效值可为：皮肤类定义,皮肤类名,或皮肤实例，
                 */
                g: function () {
                    return this._skinName;
                },
                s: function (value) {
                    this.$setFlags(33554432 /* skinNameExplicitlySet */);
                    if (this._skinName == value)
                        return;
                    this._skinName = value;
                    this.parseSkinName();
                },
            });
            /**
             * 解析skinName
             */
            p.parseSkinName = function () {
                var skinName = this._skinName;
                var skin;
                if (skinName) {
                    if (skinName.prototype) {
                        skin = new skinName();
                    }
                    else if (typeof (skinName) == "string") {
                        var clazz = lark.getDefinitionByName(skinName);
                        if (clazz) {
                            skin = new clazz();
                        }
                    }
                    else {
                        skin = skinName;
                    }
                }
                if (!lark.is(skin, 1006 /* Skin */)) {
                    skin = null;
                    DEBUG && lark.$error(2202);
                }
                this.$setSkin(skin);
            };
            p.$onAddToStage = function (stage, nestLevel) {
                _super.prototype.$onAddToStage.call(this, stage, nestLevel);
                this.checkInvalidateFlag();
                if (!this.$hasFlags(33554432 /* skinNameExplicitlySet */)) {
                    var skin = gui.Theme.$getDefaultSkin(this, stage);
                    if (skin) {
                        this.$setSkin(skin);
                    }
                }
            };
            d(p, "skin", {
                /**
                 * [只读]皮肤对象实例。
                 */
                g: function () {
                    return this.$skin;
                },
            });
            /**
             * 设置皮肤实例
             */
            p.$setSkin = function (skin) {
                var oldSkin = this.$skin;
                if (oldSkin) {
                    var skinParts = oldSkin.skinParts;
                    var length = skinParts.length;
                    for (var i = 0; i < length; i++) {
                        var partName = skinParts[i];
                        if (this[partName]) {
                            this.setSkinPart(partName, null);
                        }
                    }
                    oldSkin.hostComponent = null;
                }
                this.removeChildren();
                this.$skin = skin;
                if (skin) {
                    skin.hostComponent = this;
                    var skinParts = skin.skinParts;
                    var length = skinParts.length;
                    for (var i = 0; i < length; i++) {
                        var partName = skinParts[i];
                        var instance = skin[partName];
                        if (instance) {
                            this.setSkinPart(partName, instance);
                        }
                    }
                    var children = skin.$elementsContent;
                    if (children) {
                        var length = children.length;
                        for (var i = 0; i < length; i++) {
                            this.addChild(children[i]);
                        }
                    }
                }
                this.invalidateSize();
                this.invalidateDisplayList();
                if (this.hasListener(gui.UIEvent.SKIN_CHANGED)) {
                    gui.UIEvent.emitUIEvent(this, gui.UIEvent.SKIN_CHANGED);
                }
            };
            /**
             * 关联一个对象到逻辑组件的指定皮肤部件上。通常您不需要手动调用此方法，当使用EXML文件作为组件皮肤，此方法将会被自动调用。
             * 在运行时，EXML文件内声明的id名称将作为此方法的partName参数，而id所对应的节点对象，将作为此方法的instance参数被依次传入。
             * @param partName 皮肤部件名称
             * @param instance 皮肤部件实例
             */
            p.setSkinPart = function (partName, instance) {
                var oldInstance = this[partName];
                if (oldInstance) {
                    this.partRemoved(partName, oldInstance);
                }
                this[partName] = instance;
                if (instance) {
                    this.partAdded(partName, instance);
                }
            };
            /**
             * 子类覆盖此方法，以在皮肤部件第一次附加时对其执行一些初始化操作，例如添加事件监听，赋值缓存的属性值等。
             * @param partName 要附加的皮肤部件名称
             * @param instance 要附加的皮肤部件实例
             */
            p.partAdded = function (partName, instance) {
            };
            /**
             * 子类覆盖此方法，以在皮肤部件从逻辑组件卸载时对其执行一些清理操作，例如移除事件监听，断开缓存的引用等。
             * @param partName 要卸载的皮肤部件名称
             * @param instance 要卸载的皮肤部件实例
             */
            p.partRemoved = function (partName, instance) {
            };
            p.$setTouchChildren = function (value) {
                value = !!value;
                if (this.$hasFlags(8388608 /* enabled */)) {
                    this.$toggleFlags(2048 /* TouchChildren */, value);
                }
                else {
                    this.$toggleFlags(67108864 /* explicitTouchChildren */, value);
                }
            };
            p.$setTouchEnabled = function (value) {
                value = !!value;
                if (this.$hasFlags(8388608 /* enabled */)) {
                    this.$toggleFlags(1024 /* TouchEnabled */, value);
                }
                else {
                    this.$toggleFlags(134217728 /* explicitTouchEnabled */, value);
                }
            };
            d(p, "enabled", {
                /**
                 * 组件是否可以接受用户交互。将 enabled 属性设置为 false 后，组件会自动禁用触摸事件(将 touchEnabled 和 touchChildren 同时设置为 false)，
                 * 部分组件可能还会将皮肤的视图状态设置为"disabled",使其所有子项的颜色变暗。默认值为 true。
                 */
                g: function () {
                    return this.$hasFlags(8388608 /* enabled */);
                },
                s: function (value) {
                    this.$setEnabled(value);
                },
            });
            p.$setEnabled = function (value) {
                value = !!value;
                if (value === this.$hasFlags(8388608 /* enabled */)) {
                    return;
                }
                this.$toggleFlags(8388608 /* enabled */, value);
                if (value) {
                    this.$toggleFlags(134217728 /* explicitTouchEnabled */, this.touchEnabled);
                    this.$toggleFlags(67108864 /* explicitTouchChildren */, this.touchChildren);
                }
                else {
                    _super.prototype.$setTouchEnabled.call(this, this.$hasFlags(134217728 /* explicitTouchEnabled */));
                    _super.prototype.$setTouchChildren.call(this, this.$hasFlags(67108864 /* explicitTouchChildren */));
                }
                this.invalidateSkinState();
            };
            d(p, "currentState", {
                /**
                 * 组件的当前视图状态。显式设置此属性，将采用显式设置的值去更新皮肤状态，而忽略组件内部getCurrentSkinState()方法返回的值。
                 * 将其设置为 "" 或 null 可将取消组件外部显式设置的视图状态名称，从而采用内部getCurrentSkinState()方法返回的状态。
                 */
                g: function () {
                    return this.explicitCurrentState ? this.explicitCurrentState : this.getCurrentSkinState();
                },
                s: function (value) {
                    if (value == this.explicitCurrentState) {
                        return;
                    }
                    this.explicitCurrentState = value;
                    this.invalidateSkinState();
                },
            });
            /**
             * 标记当前需要重新验证皮肤状态
             */
            p.invalidateSkinState = function () {
                if (this.$hasFlags(16777216 /* stateIsDirty */))
                    return;
                this.$setFlags(16777216 /* stateIsDirty */);
                this.invalidateProperties();
            };
            /**
             * 返回组件当前的皮肤状态名称,子类覆盖此方法定义各种状态名
             */
            p.getCurrentSkinState = function () {
                return "";
            };
            //=======================UIComponent接口实现===========================
            /**
             * 创建子项,子类覆盖此方法以完成组件子项的初始化操作，
             * 请务必调用super.createChildren()以完成父类组件的初始化
             */
            p.createChildren = function () {
            };
            /**
             * 提交属性，子类在调用完invalidateProperties()方法后，应覆盖此方法以应用属性
             */
            p.commitProperties = function () {
                if (this.$hasFlags(16777216 /* stateIsDirty */)) {
                    this.$removeFlags(16777216 /* stateIsDirty */);
                    if (this.$skin) {
                        this.$skin.currentState = this.currentState;
                    }
                }
            };
            /**
             * 测量组件尺寸
             */
            p.measure = function () {
                lark.player.measure(this);
                var skin = this.$skin;
                if (!skin) {
                    return;
                }
                var values = this.$uiValues;
                if (!lark.isNone(skin.width)) {
                    values[16 /* measuredWidth */] = skin.width;
                }
                else {
                    if (values[16 /* measuredWidth */] < skin.minWidth) {
                        values[16 /* measuredWidth */] = skin.minWidth;
                    }
                    if (values[16 /* measuredWidth */] > skin.maxWidth) {
                        values[16 /* measuredWidth */] = skin.maxWidth;
                    }
                }
                if (!lark.isNone(skin.height)) {
                    values[17 /* measuredHeight */] = skin.height;
                }
                else {
                    if (values[17 /* measuredHeight */] < skin.minHeight) {
                        values[17 /* measuredHeight */] = skin.minHeight;
                    }
                    if (values[17 /* measuredHeight */] > skin.maxHeight) {
                        values[17 /* measuredHeight */] = skin.maxHeight;
                    }
                }
            };
            /**
             * 更新显示列表
             */
            p.updateDisplayList = function (unscaledWidth, unscaledHeight) {
                lark.player.updateDisplayList(this, unscaledWidth, unscaledHeight);
            };
            /**
             * 标记父级容器的尺寸和显示列表为失效
             */
            p.invalidateParentLayout = function () {
            };
            /**
             * 设置测量结果。
             * @param width 测量宽度
             * @param height 测量高度
             */
            p.setMeasuredSize = function (width, height) {
            };
            /**
             * 标记提交过需要延迟应用的属性
             */
            p.invalidateProperties = function () {
            };
            /**
             * 验证组件的属性
             */
            p.validateProperties = function () {
            };
            /**
             * 标记提交过需要验证组件尺寸
             */
            p.invalidateSize = function () {
            };
            /**
             * 验证组件的尺寸
             */
            p.validateSize = function (recursive) {
            };
            /**
             * 标记需要验证显示列表
             */
            p.invalidateDisplayList = function () {
            };
            /**
             * 验证子项的位置和大小，并绘制其他可视内容
             */
            p.validateDisplayList = function () {
            };
            /**
             * 立即应用组件及其子项的所有属性
             */
            p.validateNow = function () {
            };
            /**
             * 设置组件的布局宽高
             */
            p.setLayoutBoundsSize = function (layoutWidth, layoutHeight) {
            };
            /**
             * 设置组件的布局位置
             */
            p.setLayoutBoundsPosition = function (x, y) {
            };
            /**
             * 组件的布局尺寸,常用于父级的updateDisplayList()方法中
             * 按照：布局尺寸>外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸,
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getLayoutBounds = function (bounds) {
            };
            /**
             * 获取组件的首选尺寸,常用于父级的measure()方法中
             * 按照：外部显式设置尺寸>测量尺寸 的优先级顺序返回尺寸，
             * 注意此方法返回值已经包含scale和rotation。
             */
            p.getPreferredBounds = function (bounds) {
            };
            return Component;
        })(lark.Sprite);
        gui.Component = Component;
        Component.prototype.__class__ = "lark.gui.Component";
        lark.player.implementUIComponent(Component, lark.Sprite, true);
        lark.registerClass(Component, 1003 /* Component */, [1001 /* UIComponent */]);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        var isMobile = lark.Capabilities.isMobile;
        /**
         * 按钮组件
         */
        var Button = (function (_super) {
            __extends(Button, _super);
            /**
             * 创建一个按钮实例
             */
            function Button() {
                _super.call(this);
                /**
                 * [SkinPart]按钮上的文本标签
                 */
                this.labelDisplay = null;
                this._label = "";
                /**
                 * [SkinPart]按钮上的图标显示对象。
                 */
                this.iconDisplay = null;
                this._icon = null;
                /**
                 * 指示触摸点否位于按钮上。
                 */
                this.hovered = false;
                /**
                 * 指示第一次分派 TouchEvent.TOUCH_BEGIN 时，是否按下鼠标以及触摸点是否在按钮上。
                 */
                this.touchCaptured = false;
                this._stickyHighlighting = false;
                this.touchChildren = false;
                this.on(lark.TouchEvent.TOUCH_ENTER, this.mouseEventHandler, this);
                this.on(lark.TouchEvent.TOUCH_LEAVE, this.mouseEventHandler, this);
                this.on(lark.TouchEvent.TOUCH_BEGIN, this.mouseEventHandler, this);
                this.on(lark.TouchEvent.TOUCH_END, this.mouseEventHandler, this);
            }var d = __define,c=Button;p=c.prototype;
            d(p, "label", {
                /**
                 * 要在按钮上显示的文本
                 */
                g: function () {
                    return this._label;
                },
                s: function (value) {
                    this._label = value;
                    if (this.labelDisplay) {
                        this.labelDisplay.text = value;
                    }
                },
            });
            d(p, "icon", {
                /**
                 * 要在按钮上显示的图标数据
                 */
                g: function () {
                    return this._icon;
                },
                s: function (value) {
                    this._icon = value;
                    if (this.iconDisplay) {
                        this.iconDisplay.source = value;
                    }
                },
            });
            d(p, "stickyHighlighting", {
                /**
                 * 如果为 true，则按钮会在用户按下它时显示其按下时的外观，并在用户将触摸点拖离时继续显示此外观。默认值为 false。
                 */
                g: function () {
                    return this._stickyHighlighting;
                },
                s: function (value) {
                    if (value == this._stickyHighlighting)
                        return;
                    this._stickyHighlighting = value;
                    this.invalidateSkinState();
                },
            });
            /**
             * 鼠标事件处理
             */
            p.mouseEventHandler = function (event) {
                switch (event.$type) {
                    case lark.TouchEvent.TOUCH_ENTER:
                        if (event.touchDown && !this.touchCaptured) {
                            return;
                        }
                        this.hovered = true;
                        break;
                    case lark.TouchEvent.TOUCH_LEAVE:
                        this.hovered = false;
                        break;
                    case lark.TouchEvent.TOUCH_BEGIN:
                        this.$stage.on(lark.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
                        this.touchCaptured = true;
                        break;
                    case lark.TouchEvent.TOUCH_END:
                        if (event.target == this) {
                            this.hovered = true;
                            if (this.touchCaptured) {
                                this.buttonReleased();
                                this.touchCaptured = false;
                            }
                        }
                        break;
                }
                this.invalidateSkinState();
                event.updateAfterEvent();
            };
            /**
             * 舞台上鼠标弹起事件
             */
            p.stage_mouseUpHandler = function (event) {
                this.$stage.removeListener(lark.TouchEvent.TOUCH_END, this.stage_mouseUpHandler, this);
                if (event.target == this)
                    return;
                this.touchCaptured = false;
                this.invalidateSkinState();
            };
            /**
             * 返回要应用到外观的状态的名称
             */
            p.getCurrentSkinState = function () {
                if (!this.$hasFlags(8388608 /* enabled */))
                    return "disabled";
                if (this.touchCaptured && (this.hovered || this.stickyHighlighting))
                    return "down";
                if (!isMobile && (this.hovered || this.touchCaptured) && this.$skin && this.$skin.hasState("over"))
                    return "over";
                return "up";
            };
            /**
             * 子类覆盖此方法，以在皮肤部件第一次附加时对其执行一些初始化操作，例如添加事件监听，赋值缓存的属性值等。
             * @param partName 要附加的皮肤部件名称
             * @param instance 要附加的皮肤部件实例
             */
            p.partAdded = function (partName, instance) {
                if (instance === this.labelDisplay) {
                    this.labelDisplay.text = this._label;
                }
                else if (instance == this.iconDisplay) {
                    this.iconDisplay.source = this._icon;
                }
            };
            /**
             * 按钮弹起事件
             */
            p.buttonReleased = function () {
            };
            return Button;
        })(gui.Component);
        gui.Button = Button;
        Button.prototype.__class__ = "lark.gui.Button";
        lark.registerClass(Button, 1012 /* Button */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 带有标题，关闭按钮，可移动区域的面板组件。注意：当第一次通过触摸交互操作移动面板时，面板的 includeInLayout 属性将会自动被设置为false，
         * 以确保移动不会受到自动布局属性的影响。若之后还需要启用面板在父级容器中的自动布局，需手动设置 includeInLayout 为 true。
         * @event lark.gui.UIEvent.CLOSING 面板即将关闭事件，在关闭按钮被点击后抛出，监听此事件并调用event.preventDefault()能够阻止面板被关闭。
         */
        var Panel = (function (_super) {
            __extends(Panel, _super);
            /**
             * 创建一个Panel实例
             */
            function Panel() {
                _super.call(this);
                /**
                 * [SkinPart]关闭按钮
                 */
                this.closeButton = null;
                /**
                 * [SkinPart]可移动区域
                 */
                this.moveArea = null;
                /**
                 * [SkinPart]标题显示对象
                 */
                this.titleDisplay = null;
                this._title = "";
                /**
                 * 鼠标按下时的偏移量
                 */
                this.offsetPointX = 0;
                this.offsetPointY = 0;
                this.on(lark.TouchEvent.TOUCH_BEGIN, this.onWindowMouseDown, this, false, 100);
            }var d = __define,c=Panel;p=c.prototype;
            /**
             * 在窗体上按下时前置窗口
             */
            p.onWindowMouseDown = function (event) {
                this.$parent.addChild(this);
            };
            d(p, "title", {
                /**
                 * 标题文本内容
                 */
                g: function () {
                    return this._title;
                },
                s: function (value) {
                    this._title = value;
                    if (this.titleDisplay)
                        this.titleDisplay.text = this.title;
                },
            });
            p.partAdded = function (partName, instance) {
                _super.prototype.partAdded.call(this, partName, instance);
                if (instance == this.titleDisplay) {
                    this.titleDisplay.text = this._title;
                }
                else if (instance == this.moveArea) {
                    this.moveArea.on(lark.TouchEvent.TOUCH_BEGIN, this.onTouchBegin, this);
                }
                else if (instance == this.closeButton) {
                    this.closeButton.on(lark.TouchEvent.TOUCH_TAP, this.onCloseButtonClick, this);
                }
            };
            p.partRemoved = function (partName, instance) {
                _super.prototype.partRemoved.call(this, partName, instance);
                if (instance == this.moveArea) {
                    this.moveArea.removeListener(lark.TouchEvent.TOUCH_BEGIN, this.onTouchBegin, this);
                }
                else if (instance == this.closeButton) {
                    this.closeButton.removeListener(lark.TouchEvent.TOUCH_TAP, this.onCloseButtonClick, this);
                }
            };
            /**
             * 关闭按钮被点击事件
             */
            p.onCloseButtonClick = function (event) {
                if (gui.UIEvent.emitUIEvent(this, gui.UIEvent.CLOSING)) {
                    this.close();
                }
            };
            /**
             * 关闭面板，从父级容器移除自身。
             */
            p.close = function () {
                if (!this.$parent) {
                    return;
                }
                this.$parent.removeChild(this);
            };
            /**
             * 在可移动区域按下
             */
            p.onTouchBegin = function (event) {
                this.$includeInLayout = false;
                this.offsetPointX = this.x - event.stageX;
                this.offsetPointY = this.y - event.stageY;
                this.$stage.on(lark.TouchEvent.TOUCH_MOVE, this.onTouchMove, this);
                this.$stage.on(lark.TouchEvent.TOUCH_END, this.onTouchEnd, this);
            };
            /**
             * 触摸拖拽时的移动事件
             */
            p.onTouchMove = function (event) {
                this.x = event.stageX + this.offsetPointX;
                this.y += event.stageY + this.offsetPointY;
            };
            /**
             * 鼠标在舞台上弹起事件
             */
            p.onTouchEnd = function (event) {
                this.$stage.removeListener(lark.TouchEvent.TOUCH_MOVE, this.onTouchMove, this);
                this.$stage.removeListener(lark.TouchEvent.TOUCH_END, this.onTouchEnd, this);
            };
            return Panel;
        })(gui.Component);
        gui.Panel = Panel;
        Panel.prototype.__class__ = "lark.gui.Panel";
        lark.registerClass(Panel, 1011 /* Panel */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 切换按钮
         * @event lark.Event.CHANGE 选中状态发生改变，仅当触摸操作引起的选中状态改变才会抛出此事件。
         */
        var ToggleButton = (function (_super) {
            __extends(ToggleButton, _super);
            function ToggleButton() {
                _super.apply(this, arguments);
                this.$selected = false;
                /**
                 * 是否根据鼠标事件自动变换选中状态,默认true。仅框架内使用。
                 */
                this.$autoSelected = true;
            }var d = __define,c=ToggleButton;p=c.prototype;
            d(p, "selected", {
                /**
                 * 按钮处于按下状态时为 true，而按钮处于弹起状态时为 false。
                 */
                g: function () {
                    return this.$selected;
                },
                s: function (value) {
                    this.$setSelected(value);
                },
            });
            p.$setSelected = function (value) {
                value = !!value;
                if (value === this.$selected)
                    return;
                this.$selected = value;
                this.invalidateSkinState();
                gui.UIEvent.emitUIEvent(this, gui.UIEvent.VALUE_COMMIT);
            };
            /**
             * 返回要应用到外观的状态的名称
             */
            p.getCurrentSkinState = function () {
                var state = _super.prototype.getCurrentSkinState.call(this);
                if (!this.$selected) {
                    return state;
                }
                else {
                    var selectedState = state + "AndSelected";
                    var skin = this.skin;
                    if (skin && skin.hasState(selectedState)) {
                        return selectedState;
                    }
                    return state == "disabled" ? "disabled" : "down";
                }
            };
            /**
             * 当在用户单击按钮之后处理 MouseEvent.MOUSE_UP 事件时，将调用此方法
             */
            p.buttonReleased = function () {
                if (!this.$autoSelected)
                    return;
                this.selected = !this.$selected;
                this.emitWith(lark.Event.CHANGE);
            };
            return ToggleButton;
        })(gui.Button);
        gui.ToggleButton = ToggleButton;
        ToggleButton.prototype.__class__ = "lark.gui.ToggleButton";
        lark.registerClass(ToggleButton, 1013 /* ToggleButton */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 复选框
         */
        var CheckBox = (function (_super) {
            __extends(CheckBox, _super);
            /**
             * 创建一个CheckBox
             */
            function CheckBox() {
                _super.call(this);
            }var d = __define,c=CheckBox;p=c.prototype;
            return CheckBox;
        })(gui.ToggleButton);
        gui.CheckBox = CheckBox;
        CheckBox.prototype.__class__ = "lark.gui.CheckBox";
        lark.registerClass(CheckBox, 1014 /* CheckBox */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 开关按钮
         */
        var ToggleSwitch = (function (_super) {
            __extends(ToggleSwitch, _super);
            /**
             * 创建一个ToggleSwitch
             */
            function ToggleSwitch() {
                _super.call(this);
            }var d = __define,c=ToggleSwitch;p=c.prototype;
            return ToggleSwitch;
        })(gui.ToggleButton);
        gui.ToggleSwitch = ToggleSwitch;
        ToggleSwitch.prototype.__class__ = "lark.gui.ToggleSwitch";
        lark.registerClass(ToggleSwitch, 1015 /* ToggleSwitch */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        /**
         * 存储根据groupName自动创建的RadioButtonGroup列表
         */
        var automaticRadioButtonGroups = {};
        /**
         * RadioButton 组件使用户可在一组互相排斥的选择中做出一种选择
         */
        var RadioButton = (function (_super) {
            __extends(RadioButton, _super);
            /**
             * 创建一个RadioButton
             */
            function RadioButton() {
                _super.call(this);
                /**
                 * 在RadioButtonGroup中的索引
                 */
                this.$indexNumber = 0;
                /**
                 * 所属的RadioButtonGroup
                 */
                this.$radioButtonGroup = null;
                this._group = null;
                this.groupChanged = false;
                this._groupName = "radioGroup";
                this._value = null;
                this.groupName = "radioGroup";
            }var d = __define,c=RadioButton;p=c.prototype;
            d(p, "enabled", {
                /**
                 * 组件是否可以接受用户交互。默认值为true。设置此属性将影响组内所有单选按钮
                 */
                g: function () {
                    if (!this.$hasFlags(8388608 /* enabled */)) {
                        return false;
                    }
                    return !this.$radioButtonGroup || this.$radioButtonGroup.$enabled;
                },
                s: function (value) {
                    this.$setEnabled(value);
                },
            });
            d(p, "group", {
                /**
                 * 此单选按钮所属的组。同一个组的多个单选按钮之间互斥。
                 * 若不设置此属性，则根据groupName属性自动创建一个唯一的RadioButtonGroup。
                 */
                g: function () {
                    if (!this._group && this._groupName) {
                        var g = automaticRadioButtonGroups[this._groupName];
                        if (!g) {
                            g = new gui.RadioButtonGroup();
                            g.$name = this._groupName;
                            automaticRadioButtonGroups[this._groupName] = g;
                        }
                        this._group = g;
                    }
                    return this._group;
                },
                s: function (value) {
                    if (this._group == value)
                        return;
                    if (this.$radioButtonGroup)
                        this.$radioButtonGroup.$removeInstance(this, false);
                    this._group = value;
                    this._groupName = value ? this.group.$name : "radioGroup";
                    this.groupChanged = true;
                    this.invalidateProperties();
                    this.invalidateDisplayList();
                },
            });
            d(p, "groupName", {
                /**
                 * 所属组的名称,具有相同组名的多个单选按钮之间互斥。默认值:"radioGroup"。
                 * 可以把此属性当做设置组的一个简便方式，作用与设置group属性相同,。
                 */
                g: function () {
                    return this._groupName;
                },
                s: function (value) {
                    if (!value || value == "")
                        return;
                    this._groupName = value;
                    if (this.$radioButtonGroup)
                        this.$radioButtonGroup.$removeInstance(this, false);
                    this._group = null;
                    this.groupChanged = true;
                    this.invalidateProperties();
                    this.invalidateDisplayList();
                },
            });
            p.$setSelected = function (value) {
                _super.prototype.$setSelected.call(this, value);
                this.invalidateDisplayList();
            };
            d(p, "value", {
                /**
                 * 与此单选按钮关联的自定义数据。
                 */
                g: function () {
                    return this._value;
                },
                s: function (value) {
                    if (this._value == value)
                        return;
                    this._value = value;
                    if (this.$selected && this.group)
                        gui.UIEvent.emitUIEvent(this.group, gui.UIEvent.VALUE_COMMIT);
                },
            });
            p.commitProperties = function () {
                if (this.groupChanged) {
                    this.addToGroup();
                    this.groupChanged = false;
                }
                _super.prototype.commitProperties.call(this);
            };
            p.updateDisplayList = function (unscaledWidth, unscaledHeight) {
                _super.prototype.updateDisplayList.call(this, unscaledWidth, unscaledHeight);
                if (this.group) {
                    if (this.$selected)
                        this._group.$setSelection(this, false);
                    else if (this.group.selection == this)
                        this._group.$setSelection(null, false);
                }
            };
            p.buttonReleased = function () {
                if (!this.enabled || this.selected)
                    return;
                if (!this.$radioButtonGroup)
                    this.addToGroup();
                _super.prototype.buttonReleased.call(this);
                this.group.$setSelection(this, true);
            };
            /**
             * 添此单选按钮加到组
             */
            p.addToGroup = function () {
                var g = this.group;
                if (g)
                    g.$addInstance(this);
                return g;
            };
            return RadioButton;
        })(gui.ToggleButton);
        gui.RadioButton = RadioButton;
        RadioButton.prototype.__class__ = "lark.gui.RadioButton";
        lark.registerClass(RadioButton, 1016 /* RadioButton */);
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-2015, Egret Technology Inc.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var lark;
(function (lark) {
    var gui;
    (function (gui) {
        //1001~2000预留给lark.gui包下的类和接口
        /**
         * 为Lark GUI模块内的类或接口定义的枚举值。通常作为实例检查类型 lark.is() 方法的参数。
         */
        (function (Types) {
            /**
             * GUI显示对象基类
             */
            Types[Types["UIComponent"] = 1001] = "UIComponent";
            /**
             * GUI容器基类
             */
            Types[Types["Group"] = 1002] = "Group";
            /**
             * Component 类定义可设置外观的组件的基类。Component 类所使用的外观通常是 Skin 类的子类。
             */
            Types[Types["Component"] = 1003] = "Component";
            /**
             * Label 是可以呈示一行或多行统一格式文本的UI组件。要显示的文本由 text 属性确定。文本格式由样式属性指定，例如 fontFamily 和 fontSize。
             * 因为 Label 运行速度快且占用内存少，所以它特别适合用于显示多个小型非交互式文本的情况，例如，项呈示器和 Button 外观中的标签。
             * 在 Label 中，将以下三个字符序列识别为显式换行符：CR（“\r”）、LF（“\n”）和 CR+LF（“\r\n”）。
             * 如果没有为 Label 指定宽度，则由这些显式换行符确定的最长行确定 Label 的宽度。
             * 如果指定了宽度，则指定文本将在组件边界的右边缘换行，如果文本扩展到低于组件底部，则将被剪切。
             */
            Types[Types["Label"] = 1004] = "Label";
            /**
             * Image 控件允许您在运行时显示 JPEG、PNG 等图片文件文件。Image 继承至 Bitmap，因此您可以直接对其 bitmapData 属性，
             * 赋值从外部加载得到的位图数据以显示对应图片。同时，Image 还提供了更加方便的 source 属性，source 属性可以接受一个网络图片url作为值，
             * 赋值为url后，它内部会自动去加载并显示图片。并且您同样也可以直接把 BitmapData 对象赋值给 source 属性以显示图片。
             * Image 控件可以直接替代 Bitmap 在显示列表中使用。
             *
             * @event lark.Event.COMPLETE 当图片加载完成后调度
             */
            Types[Types["Image"] = 1005] = "Image";
            /**
             * 含有视图状态功能的皮肤基类。
             */
            Types[Types["Skin"] = 1006] = "Skin";
            /**
             * 皮肤主题。实例化一个主题，能够在运行时修改全局的默认皮肤。
             */
            Types[Types["Theme"] = 1007] = "Theme";
            /**
             * UI事件
             */
            Types[Types["UIEvent"] = 1008] = "UIEvent";
            /**
             * 容器布局基类。若要创建使用 Group 容器的自定义布局，必须扩展 LayoutBase 或其子类之一。
             * 子类必须实现 updateDisplayList() 方法（定位 target Group 的子项并调整这些子项的大小）和 measure() 方法（计算 target 的默认大小）。
             */
            Types[Types["LayoutBase"] = 1009] = "LayoutBase";
            /**
             * BasicLayout 类根据其各个设置彼此独立地排列布局元素。
             * BasicLayout（也称为绝对布局）要求显式定位每个容器子代。可以使用子代的 x 和 y 属性，或使用约束来定位每个子代。
             */
            Types[Types["BasicLayout"] = 1010] = "BasicLayout";
            /**
             * 带有标题，关闭按钮，可移动区域的面板组件。注意：当第一次通过触摸交互操作移动面板时，面板的 includeInLayout 属性将会自动被设置为false，
             * 以确保移动不会受到自动布局属性的影响。若之后还需要启用面板在父级容器中的自动布局，需手动设置 includeInLayout 为 true。
             * @event lark.gui.UIEvent.CLOSING 面板即将关闭事件，在关闭按钮被点击后抛出，监听此事件并调用event.preventDefault()能够阻止面板被关闭。
             */
            Types[Types["Panel"] = 1011] = "Panel";
            /**
             * 按钮组件
             */
            Types[Types["Button"] = 1012] = "Button";
            /**
             * 切换按钮
             */
            Types[Types["ToggleButton"] = 1013] = "ToggleButton";
            /**
             * 复选框
             */
            Types[Types["CheckBox"] = 1014] = "CheckBox";
            /**
             * 开关按钮
             */
            Types[Types["ToggleSwitch"] = 1015] = "ToggleSwitch";
            /**
             * RadioButton 组件使用户可在一组互相排斥的选择中做出一种选择
             */
            Types[Types["RadioButton"] = 1016] = "RadioButton";
            /**
             * RadioButtonGroup 组件定义一组 RadioButton 组件，这些组件相互排斥；因此，用户每次只能选择一个 RadioButton 组件
             */
            Types[Types["RadioButtonGroup"] = 1017] = "RadioButtonGroup";
        })(gui.Types || (gui.Types = {}));
        var Types = gui.Types;
    })(gui = lark.gui || (lark.gui = {}));
})(lark || (lark = {}));
